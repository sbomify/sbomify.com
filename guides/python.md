---
layout: page
permalink: /guides/python/
title: "SBOM Generation Guide for Python - pip, Poetry, Pipenv, uv"
description: "Learn how to generate Software Bill of Materials for Python projects. Complete guide with requirements.txt, poetry.lock, Pipfile.lock, and pyproject.toml examples."
section: guides
---

## Source vs Build SBOMs

Before we dive into the actual guide, let's start by talking about SBOM generation. Generally speaking, an SBOM is either built from source (also known as 'pre-build' in CycloneDX terminology) or built after installation. When we talk about source SBOMs, we normally refer to generating an SBOM from a lockfile, and for built SBOMs, we look at what has been installed by the package manager. These might seem interchangeable, and the output might be identical. However, this really boils down to the quality of the lockfile, so let's dive into this with some examples.

## Lockfile Example

There are a lot of ways to manage packages in Python. The most widely used way to pin dependencies in Python is to use `requirements.txt` with `pip`. We'll talk about why you might not want to use this approach later on, but let's unpack some scenarios where you might end up with an incomplete SBOM.

Let's imagine that we have a Flask-based Python server. It's possible that your `requirements.txt` file will only list Flask like this:

```
Flask==3.0.3
```

Every time you run `pip install -r requirements.txt`, you'll have all your packages installed.

However, if we were to try to generate an SBOM for this, we'd just get one entry - namely Flask. This is of course incomplete. None of Flask's dependencies (i.e., transitive dependencies) are captured here. Thus, it's important that we capture **all** the dependencies generated by `pip freeze` and lock them into our `requirements.txt` file, resulting in something that looks like this:

```
blinker==1.8.2
click==8.1.7
Flask==3.0.3
importlib_metadata==8.5.0
itsdangerous==2.2.0
Jinja2==3.1.4
MarkupSafe==2.1.5
Werkzeug==3.0.4
zipp==3.20.2
```

Now, this probably doesn't come as a surprise to any experienced developer, but it's still important to highlight that the SBOM is directly correlated to the quality of the lockfile. If it's missing there, it will be missing in the SBOM.

Now, let's move on to some more complicated issues.

### Advanced Gotchas

If you're a seasoned Python developer, you've most likely run across `requirements.txt`, `setup.cfg`, or `pyproject.toml` files that include expressions like `foobar>=1.2.3` (defined in [PEP 440](https://peps.python.org/pep-0440/#version-specifiers)). While there are good reasons for using ranges or less/more-than expressions for versions, this can really create issues when we are using these for SBOM generation. This is where source/pre-build and build SBOMs will diverge. Technically speaking, it's impossible to generate a source/pre-build SBOM for a lockfile that has non-precise pinning, as the version is ambiguous.

### The Importance of Including Hashes

Modern Python package managers like [Poetry](https://python-poetry.org/), [pipenv](https://pipenv.pypa.io/en/latest/), and [Conda](https://docs.conda.io/projects/conda/en/latest/index.html) will automatically add cryptographic hashes to all installed packages.

This is very important, and a requirement if you want to meet NTIA Minimum Elements for your SBOMs. Remember, if you're building the SBOM from a lockfile, the quality of the lockfile is only as good as the input.

It is possible to add hashes to `requirements.txt` files too, but it requires a bit of extra work:

```bash
$ pip install pip-tools
$ pip freeze > requirements.in
$ pip-compile \
    --generate-hashes requirements.in \
    > requirements.txt
```

You'll now notice that if you open up your new `requirements.txt` file, you have hashes added to each package:

```bash
$ cat requirements.txt
[...]
flask==3.0.3 \
    --hash=sha256:34e815dfaa43340d1d15a5c3a02b8476004037eb4840b34910c6e21679d288f3 \
    --hash=sha256:ceb27b0af3823ea2737928a4d99d125a06175b8512c445cbd9a9ce200ef76842
[...]
```

It is however important to point out that this is less supported in SBOM generation tools compared to the those of other package managers as it is less common.

## Generating an SBOM

SBOM generation is the first step in the [SBOM lifecycle]({{ site.url }}/features/generate-collaborate-analyze/). After generation, you typically need to enrich your SBOM with package metadata and augment it with your organization's details.

![Lifecycle](/assets/images/d2/lifecycle.svg)

### Using sbomify GitHub Action (Recommended)

The [sbomify GitHub Action](https://github.com/sbomify/github-action/) is a swiss army knife for SBOMs that automatically selects the best generation tool for your ecosystem, enriches the output with package metadata, and optionally augments it with your business informationâ€”all in one step.

For Python, sbomify uses **cyclonedx-py** under the hood as it provides the most accurate results for Python lockfiles, including proper hash support.

**Standalone (no account needed):**

```yaml
- uses: sbomify/github-action@master
  env:
    LOCK_FILE: requirements.txt
    OUTPUT_FILE: sbom.cdx.json
    COMPONENT_NAME: my-python-app
    COMPONENT_VERSION: ${{ github.ref_name }}
    ENRICH: true
    UPLOAD: false
```

Using `github.ref_name` automatically captures your git tag (e.g., `v1.2.3`) as the SBOM version. For rolling releases without tags, use `github.sha` instead. See our [SBOM versioning guide]({{ site.url }}/guides/how-to-version-sboms/) for best practices.

**With sbomify platform (adds augmentation and upload):**

```yaml
- uses: sbomify/github-action@master
  env:
    TOKEN: ${{ secrets.SBOMIFY_TOKEN }}
    COMPONENT_ID: my-component-id
    LOCK_FILE: requirements.txt
    OUTPUT_FILE: sbom.cdx.json
    AUGMENT: true
    ENRICH: true
```

The action supports all Python lockfiles: `requirements.txt`, `poetry.lock`, `Pipfile.lock`, `uv.lock`, and `pyproject.toml`.

### Alternative Tools

If you prefer to run SBOM generation tools manually:

**cyclonedx-py (Python-native, recommended for manual use):**

```bash
pip install cyclonedx-bom
cyclonedx-py requirements requirements.txt --output-format json -o sbom.cdx.json
```

This is the same tool sbomify uses under the hood. It properly handles hashes in `requirements.txt` files.

**Trivy:**

```bash
trivy fs --format cyclonedx --output sbom.cdx.json requirements.txt
```

Note: Trivy does not support reading hashes from `requirements.txt` files.

**cdxgen:**

```bash
cdxgen -o sbom.cdx.json
```

When using these tools directly, you'll need to handle enrichment and augmentation separately. See our [Resources page]({{ site.url }}/resources/#python) for more Python SBOM tools.

### GitLab CI

```yaml
generate-sbom:
  image: sbomifyhub/sbomify-action
  variables:
    LOCK_FILE: requirements.txt
    OUTPUT_FILE: sbom.cdx.json
    UPLOAD: "false"
    ENRICH: "true"
  script:
    - /sbomify.sh
```

## Further Reading

Related blog posts:

- [How to Generate SBOMs for Python Packages with pipdeptree and cyclonedx-py]({{ site.url }}/2024/07/30/generate-sboms-for-python-packages-with-pipdeptree-and-cyclonedx-py/) - Tutorial on generating CycloneDX SBOMs including transitive dependencies and best practices for pinning with hashes

## Further Resources

For more SBOM tools and resources, see our [SBOM Resources]({{ site.url }}/resources/) page, which includes additional Python-specific tools like CycloneDX Python, sbom4python, and SPDX Python libraries.

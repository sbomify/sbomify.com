<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sbomify</title><link>https://sbomify.com/tags/docker/</link><description>Your Security Artifact Hub. From zero to SBOM hero. Generate, manage, and share SBOMs and compliance documents. Built for CRA compliance and seamless integration with your existing tools.</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 03 Jan 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://sbomify.com/tags/docker/" rel="self" type="application/rss+xml"/><item><title>Container Security: Best Practices for Securing Docker and Kubernetes</title><link>https://sbomify.com/2026/01/03/container-security-best-practices/</link><pubDate>Sat, 03 Jan 2026 00:00:00 +0000</pubDate><guid>https://sbomify.com/2026/01/03/container-security-best-practices/</guid><description>&lt;p>Container security is the practice of protecting containerized applications and their infrastructure throughout the entire lifecycle — from building container images through deployment and runtime operations. Containers package applications with their dependencies into isolated units, but this isolation does not automatically equal security. Every layer of a container image, from the base operating system to application dependencies, represents a potential attack surface that must be managed.&lt;/p>
&lt;p>&lt;img src="https://sbomify.com/assets/images/d2/container-security-layers.svg" alt="Container image layers with separate SBOMs feeding into security controls">&lt;/p>
&lt;h2 id="what-is-container-security">What Is Container Security?&lt;/h2>
&lt;p>Container security encompasses the tools, practices, and policies used to protect containerized workloads. Unlike traditional application security, container security must address concerns at multiple layers: the container image, the container runtime, the orchestration platform (typically Kubernetes), the host operating system, and the network.&lt;/p>
&lt;p>Containers have become the standard deployment model for cloud-native applications. According to the &lt;a href="https://www.cncf.io/">Cloud Native Computing Foundation&lt;/a>, the majority of organizations now run containerized workloads in production. This widespread adoption makes container security a critical discipline — a compromised container image pulled from a public registry can affect thousands of deployments.&lt;/p>
&lt;p>The challenge is compounded by the ephemeral nature of containers. Unlike traditional servers that persist for months or years, containers may exist for seconds or minutes. Security practices must be automated and embedded into the build and deployment pipeline rather than applied manually.&lt;/p>
&lt;h2 id="container-image-security">Container Image Security&lt;/h2>
&lt;p>The container image is the foundation of container security. An image that ships with known vulnerabilities, outdated packages, or unnecessary components creates risk before the container even starts.&lt;/p>
&lt;h3 id="base-image-selection">Base Image Selection&lt;/h3>
&lt;p>The choice of base image has an outsized impact on security. A full Linux distribution (like Ubuntu or Debian) may include hundreds of packages that your application never uses but that increase the attack surface. Minimal base images reduce this risk.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Base Image Type&lt;/th>
&lt;th>Packages&lt;/th>
&lt;th>Attack Surface&lt;/th>
&lt;th>Use Case&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Distroless&lt;/strong> (e.g., &lt;code>gcr.io/distroless&lt;/code>)&lt;/td>
&lt;td>Application runtime only&lt;/td>
&lt;td>Minimal&lt;/td>
&lt;td>Production workloads&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;a href="https://www.chainguard.dev/chainguard-images">Chainguard Images&lt;/a>&lt;/strong>&lt;/td>
&lt;td>Minimal, zero/low-CVE packages&lt;/td>
&lt;td>Minimal&lt;/td>
&lt;td>Production workloads, compliance-sensitive environments&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;a href="https://www.docker.com/products/hardened-images/">Docker Hardened Images&lt;/a>&lt;/strong>&lt;/td>
&lt;td>Distroless Debian/Alpine, non-root&lt;/td>
&lt;td>Minimal&lt;/td>
&lt;td>Production workloads, regulated environments&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Alpine Linux&lt;/strong>&lt;/td>
&lt;td>~15 MB base, musl libc&lt;/td>
&lt;td>Small&lt;/td>
&lt;td>General purpose, size-sensitive&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Slim variants&lt;/strong> (e.g., &lt;code>python:3.12-slim&lt;/code>)&lt;/td>
&lt;td>Stripped-down distribution&lt;/td>
&lt;td>Medium&lt;/td>
&lt;td>Language-specific applications&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Full distribution&lt;/strong> (e.g., &lt;code>ubuntu:24.04&lt;/code>)&lt;/td>
&lt;td>Full package set&lt;/td>
&lt;td>Large&lt;/td>
&lt;td>Development, debugging&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>For production, prefer hardened, distroless, or slim images. Fewer packages means fewer potential vulnerabilities and a smaller SBOM — making both security management and compliance simpler.&lt;/p>
&lt;p>Two hardened image providers stand out for security-conscious teams:&lt;/p>
&lt;p>&lt;a href="https://www.chainguard.dev/chainguard-images">Chainguard Images&lt;/a> are built from the ground up on &lt;a href="https://github.com/wolfi-dev">Wolfi&lt;/a>, a Linux distribution designed specifically for containers. They are rebuilt daily, ship with zero or near-zero known CVEs, and include high-quality SBOMs out of the box. Available as drop-in replacements for popular base images like Python, Node.js, and Go.&lt;/p>
&lt;p>&lt;a href="https://www.docker.com/products/hardened-images/">Docker Hardened Images&lt;/a> (DHI) take a different approach — hardening familiar Debian and Alpine bases by stripping them down to distroless principles (no shell, no package manager, non-root by default). Docker &lt;a href="https://www.docker.com/blog/docker-hardened-images-for-every-developer/">made the full catalog of 1,000+ images free and open source&lt;/a> under Apache 2.0 in late 2025. Every image ships with an SBOM, &lt;a href="https://slsa.dev/">SLSA&lt;/a> Build Level 3 provenance, and &lt;a href="https://www.cisa.gov/resources-tools/resources/minimum-requirements-vulnerability-exploitability-exchange-vex">VEX&lt;/a> metadata. The Enterprise tier adds FIPS-enabled and STIG-hardened variants for regulated environments.&lt;/p>
&lt;h3 id="image-scanning">Image Scanning&lt;/h3>
&lt;p>Container image scanning analyzes the contents of an image for known vulnerabilities by matching installed packages and libraries against vulnerability databases like the &lt;a href="https://nvd.nist.gov/">NVD&lt;/a> and &lt;a href="https://osv.dev/">OSV&lt;/a>.&lt;/p>
&lt;p>Key scanning tools include:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://github.com/aquasecurity/trivy">Trivy&lt;/a>&lt;/strong> — Open source scanner from Aqua that detects vulnerabilities in OS packages, language-specific dependencies, and misconfigurations&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://github.com/anchore/grype">Grype&lt;/a>&lt;/strong> — Open source vulnerability scanner from Anchore&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://snyk.io/product/container-vulnerability-management/">Snyk Container&lt;/a>&lt;/strong> — Commercial scanner with developer workflow integration&lt;/li>
&lt;/ul>
&lt;p>Scanning should happen at multiple points: during the CI/CD build, before images are pushed to a registry, and continuously against images already in production (since new vulnerabilities are disclosed daily).&lt;/p>
&lt;h3 id="container-sboms-separate-layers-separate-sboms">Container SBOMs: Separate Layers, Separate SBOMs&lt;/h3>
&lt;p>A containerized application has two distinct layers with different component profiles: the &lt;strong>base image layer&lt;/strong> (OS packages, system libraries) and the &lt;strong>application layer&lt;/strong> (your code&amp;rsquo;s dependencies from lock files). Rather than combining everything into a single monolithic SBOM, the best practice is to generate &lt;strong>separate SBOMs for each layer&lt;/strong> and organize them hierarchically.&lt;/p>
&lt;p>This separation matters for several reasons:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Different update cadences.&lt;/strong> Base image packages change when you rebuild with a new base image; application dependencies change when you update your lock file. Separate SBOMs let you track each independently.&lt;/li>
&lt;li>&lt;strong>Different vulnerability profiles.&lt;/strong> A glibc vulnerability in the base image is a different remediation path than a vulnerability in an npm package. Separate SBOMs make triage clearer.&lt;/li>
&lt;li>&lt;strong>Cleaner compliance.&lt;/strong> Compliance reviewers can evaluate OS-level and application-level components independently, with the correct tool and context for each.&lt;/li>
&lt;/ul>
&lt;p>The &lt;a href="https://github.com/sbomify/github-action/">sbomify GitHub Action&lt;/a> supports this workflow directly — generate an Application SBOM from your lock file and a Container SBOM from the built image, then organize both under a single product using sbomify&amp;rsquo;s &lt;a href="https://sbomify.com/features/sbom-hierarchy/">Product → Project → Component hierarchy&lt;/a>. For step-by-step instructions, see our &lt;a href="https://sbomify.com/guides/docker/">Docker SBOM guide&lt;/a>.&lt;/p>
&lt;h2 id="runtime-security">Runtime Security&lt;/h2>
&lt;p>Image scanning catches known vulnerabilities before deployment, but runtime security protects against exploitation of unknown flaws, misconfigurations, and malicious behavior during execution.&lt;/p>
&lt;h3 id="principle-of-least-privilege">Principle of Least Privilege&lt;/h3>
&lt;p>Containers should run with the minimum permissions required:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Run as non-root.&lt;/strong> The default user in many container images is root. Always specify a non-root user in your Dockerfile (&lt;code>USER nonroot&lt;/code>) or enforce this via Kubernetes security contexts.&lt;/li>
&lt;li>&lt;strong>Drop capabilities.&lt;/strong> Linux capabilities grant fine-grained privileges. Drop all capabilities and add back only those required (&lt;code>--cap-drop=ALL --cap-add=NET_BIND_SERVICE&lt;/code>).&lt;/li>
&lt;li>&lt;strong>Read-only filesystem.&lt;/strong> Mount the container filesystem as read-only where possible (&lt;code>--read-only&lt;/code>), using tmpfs mounts for directories that require writes.&lt;/li>
&lt;li>&lt;strong>No privilege escalation.&lt;/strong> Set &lt;code>allowPrivilegeEscalation: false&lt;/code> in Kubernetes security contexts to prevent processes from gaining additional privileges.&lt;/li>
&lt;/ul>
&lt;h3 id="secrets-management">Secrets Management&lt;/h3>
&lt;p>Never bake secrets (API keys, database credentials, certificates) into container images. Images are stored in registries and can be inspected by anyone with access. Instead:&lt;/p>
&lt;ul>
&lt;li>Use Kubernetes Secrets or a dedicated secrets manager (HashiCorp Vault, AWS Secrets Manager)&lt;/li>
&lt;li>Mount secrets as files or environment variables at runtime&lt;/li>
&lt;li>Rotate secrets regularly and audit access&lt;/li>
&lt;/ul>
&lt;h3 id="runtime-monitoring">Runtime Monitoring&lt;/h3>
&lt;p>Runtime security tools observe container behavior and detect anomalies:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Unexpected processes&lt;/strong> — A web server container suddenly running a shell may indicate compromise&lt;/li>
&lt;li>&lt;strong>Unusual network connections&lt;/strong> — Outbound connections to unknown IP addresses&lt;/li>
&lt;li>&lt;strong>File system modifications&lt;/strong> — Changes to binaries or configuration files in a read-only container&lt;/li>
&lt;li>&lt;strong>Privilege escalation attempts&lt;/strong> — Attempts to gain root access&lt;/li>
&lt;/ul>
&lt;h2 id="kubernetes-security">Kubernetes Security&lt;/h2>
&lt;p>For organizations running containers at scale, Kubernetes introduces its own security considerations.&lt;/p>
&lt;h3 id="network-policies">Network Policies&lt;/h3>
&lt;p>By default, Kubernetes allows all pod-to-pod communication within a cluster. Network policies restrict this to only the connections that are necessary:&lt;/p>
&lt;ul>
&lt;li>Isolate namespaces so that development and production workloads cannot communicate&lt;/li>
&lt;li>Restrict ingress to only the pods that need to receive traffic&lt;/li>
&lt;li>Restrict egress to only the external services that pods need to reach&lt;/li>
&lt;/ul>
&lt;h3 id="pod-security-standards">Pod Security Standards&lt;/h3>
&lt;p>Kubernetes &lt;a href="https://kubernetes.io/docs/concepts/security/pod-security-standards/">Pod Security Standards&lt;/a> define three levels of restriction:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Privileged&lt;/strong> — Unrestricted (use only when necessary)&lt;/li>
&lt;li>&lt;strong>Baseline&lt;/strong> — Prevents known privilege escalations&lt;/li>
&lt;li>&lt;strong>Restricted&lt;/strong> — Hardened configuration following security best practices&lt;/li>
&lt;/ul>
&lt;p>Enforce at least the Baseline level for all production workloads. Use the Restricted level where possible.&lt;/p>
&lt;h3 id="supply-chain-security-for-images">Supply Chain Security for Images&lt;/h3>
&lt;p>Ensure that only trusted, scanned images run in your cluster:&lt;/p>
&lt;ul>
&lt;li>Use a private container registry with access controls&lt;/li>
&lt;li>Sign images and verify signatures before deployment (using tools like &lt;a href="https://docs.sigstore.dev/cosign/">Sigstore cosign&lt;/a>)&lt;/li>
&lt;li>Implement admission controllers that reject unsigned or unscanned images&lt;/li>
&lt;li>Pin images to specific digests rather than mutable tags (&lt;code>:latest&lt;/code> can change without notice)&lt;/li>
&lt;li>Consider using hardened base images from &lt;a href="https://www.chainguard.dev/chainguard-images">Chainguard&lt;/a> or &lt;a href="https://www.docker.com/products/hardened-images/">Docker Hardened Images&lt;/a> that ship with built-in SBOMs, provenance attestations, and near-zero CVEs&lt;/li>
&lt;/ul>
&lt;h2 id="container-security-and-sboms">Container Security and SBOMs&lt;/h2>
&lt;p>SBOMs play a central role in container security by providing the component visibility needed for effective vulnerability management.&lt;/p>
&lt;h3 id="why-separate-container-sboms-matter">Why Separate Container SBOMs Matter&lt;/h3>
&lt;p>A typical container image may contain hundreds of packages across multiple layers. Without SBOMs, identifying whether a newly disclosed vulnerability affects your containers requires manual investigation of each image — a process that does not scale.&lt;/p>
&lt;p>With separate SBOMs for each container layer, organized in a &lt;a href="https://sbomify.com/features/sbom-hierarchy/">hierarchical structure&lt;/a>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://sbomify.com/2026/02/01/sbom-scanning-vulnerability-detection/">Vulnerability scanning&lt;/a> becomes targeted.&lt;/strong> Match base image SBOMs against OS-level advisories and application SBOMs against language-specific vulnerability databases (&lt;a href="https://nvd.nist.gov/">NVD&lt;/a>, &lt;a href="https://osv.dev/">OSV&lt;/a>, &lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA KEV catalog&lt;/a>).&lt;/li>
&lt;li>&lt;strong>Incident response accelerates.&lt;/strong> When a new critical &lt;a href="https://sbomify.com/2025/12/18/cve-vulnerability-explained/">CVE&lt;/a> is disclosed, query your SBOM repository to immediately identify affected images — and know whether the vulnerability is in the base image or your application dependencies.&lt;/li>
&lt;li>&lt;strong>Compliance requirements are met.&lt;/strong> The &lt;a href="https://sbomify.com/compliance/eu-cra/">EU CRA&lt;/a> and &lt;a href="https://sbomify.com/compliance/eo-14028/">EO 14028&lt;/a> require component documentation for software products, including containerized applications.&lt;/li>
&lt;li>&lt;strong>Base image risk is visible.&lt;/strong> Container SBOMs expose the &lt;a href="https://sbomify.com/2026/01/29/what-is-a-dependency-in-software/">dependency&lt;/a> chain inherited from base images that developers may not be aware of, kept separate from application-level components for clarity.&lt;/li>
&lt;/ul>
&lt;p>For detailed instructions on generating separate SBOMs from container images, see our &lt;a href="https://sbomify.com/guides/docker/">Docker SBOM guide&lt;/a>. For a broader overview of SBOM tools, see our &lt;a href="https://sbomify.com/resources/">resources page&lt;/a>.&lt;/p>
&lt;h2 id="best-practices">Best Practices&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Scan images at every stage.&lt;/strong> Integrate scanning into CI/CD (build-time), the container registry (push-time), and production (runtime). New vulnerabilities are disclosed daily — a clean image today may be vulnerable tomorrow.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Use hardened or minimal base images.&lt;/strong> Choose hardened images (&lt;a href="https://www.chainguard.dev/chainguard-images">Chainguard&lt;/a>, &lt;a href="https://www.docker.com/products/hardened-images/">Docker Hardened Images&lt;/a>), distroless, or slim variants for production. Fewer packages means fewer vulnerabilities and a smaller attack surface.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Generate separate SBOMs per layer.&lt;/strong> Generate an application SBOM from your lock file and a container SBOM from the built image. Organize both under a single product in your &lt;a href="https://sbomify.com/2026/01/18/sbom-management-best-practices/">SBOM management platform&lt;/a> for continuous vulnerability monitoring.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Run containers as non-root.&lt;/strong> Never run production containers as the root user. Configure security contexts to drop unnecessary capabilities and prevent privilege escalation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Implement network policies.&lt;/strong> Do not rely on default allow-all networking. Define explicit network policies that restrict communication to only what is required.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Sign and verify images.&lt;/strong> Use image signing to establish provenance and prevent deployment of tampered images. Verify signatures with admission controllers in Kubernetes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Keep base images up to date.&lt;/strong> Regularly rebuild images with updated base layers to pick up security patches. Automate this with scheduled rebuilds in your CI/CD pipeline.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Manage secrets properly.&lt;/strong> Never embed secrets in images. Use dedicated secrets management tools and mount secrets at runtime.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="frequently-asked-questions">Frequently Asked Questions&lt;/h2>
&lt;h3 id="what-is-container-security-1">What is container security?&lt;/h3>
&lt;p>Container security is the practice of protecting containerized applications and their infrastructure throughout the lifecycle — from building images through deployment and runtime operations. It encompasses image scanning, vulnerability management, runtime protection, network policies, secrets management, and access control for container orchestration platforms like Kubernetes.&lt;/p>
&lt;h3 id="how-do-you-scan-container-images-for-vulnerabilities">How do you scan container images for vulnerabilities?&lt;/h3>
&lt;p>Container images are scanned by analyzing their contents (OS packages, language libraries, application dependencies) against vulnerability databases like the NVD and OSV. Tools like Trivy, Grype, and Snyk perform this analysis. Scanning should be integrated into CI/CD pipelines, container registries, and production monitoring to catch vulnerabilities at every stage.&lt;/p>
&lt;h3 id="what-is-a-container-sbom">What is a container SBOM?&lt;/h3>
&lt;p>A container SBOM is a Software Bill of Materials generated from a built container image, documenting the OS-level packages and system libraries in the base image. Best practice is to generate this separately from your application SBOM (which covers your code&amp;rsquo;s dependencies from lock files) and organize both under a product hierarchy. This separation keeps vulnerability triage and compliance clear. See our &lt;a href="https://sbomify.com/guides/docker/">Docker SBOM guide&lt;/a> for detailed instructions on generating separate SBOMs for each layer.&lt;/p>
&lt;h3 id="how-does-kubernetes-improve-container-security">How does Kubernetes improve container security?&lt;/h3>
&lt;p>Kubernetes provides security mechanisms including Pod Security Standards (restricting container privileges), Network Policies (controlling pod-to-pod communication), RBAC (role-based access control), Secrets management, and admission controllers (enforcing policies on what can be deployed). These features must be actively configured — Kubernetes defaults are permissive.&lt;/p>
&lt;h3 id="why-should-containers-run-as-non-root">Why should containers run as non-root?&lt;/h3>
&lt;p>Running containers as root means that a compromise of the application gives the attacker root privileges inside the container, which in some configurations can lead to host escape. Running as a non-root user limits the blast radius of a compromise. Combined with dropping capabilities and setting &lt;code>allowPrivilegeEscalation: false&lt;/code>, non-root containers significantly reduce risk.&lt;/p></description><category>education</category></item><item><title>GitHub Action module with Attestation</title><link>https://sbomify.com/2024/10/31/github-action-update-and-attestation/</link><pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><guid>https://sbomify.com/2024/10/31/github-action-update-and-attestation/</guid><description>&lt;p>Over the last few weeks, we&amp;rsquo;ve made some significant updates to our &lt;a href="https://github.com/sbomify/github-action">GitHub Actions module&lt;/a>. Since our last update, we&amp;rsquo;ve added a few new features.&lt;/p>
&lt;h2 id="changelog">Changelog&lt;/h2>
&lt;ul>
&lt;li>Support for Dart lockfiles&lt;/li>
&lt;li>Support for Docker images (system packages only)&lt;/li>
&lt;li>Full support for &lt;a href="https://sbomify.com/features/generate-collaborate-analyze/">Enrichment and Augmentation&lt;/a>, meaning we can automatically complete your SBOMs to make them NTIA Minimum Elements compatible&lt;/li>
&lt;li>Documentation on how to use attestation with the GitHub Actions module (more on that below)&lt;/li>
&lt;li>Bumped versions of various sub-components&lt;/li>
&lt;li>Various bug fixes&lt;/li>
&lt;/ul>
&lt;h2 id="using-attestation">Using Attestation&lt;/h2>
&lt;p>Thanks to recent improvements by GitHub, generating an attestation is now very straightforward. Behind the scenes, the GitHub Actions module &lt;a href="https://github.com/actions/attest-build-provenance">attest-build-provenance&lt;/a> will automatically generate a &lt;a href="https://slsa.dev/spec/v1.0/provenance">SLSA build provenance&lt;/a> predicate using the &lt;a href="https://github.com/in-toto/attestation/tree/main/spec/v1">in-toto&lt;/a> format. All you need to do is instruct our GitHub Actions module to write the SBOM to disk, and then point the attestation tool to this file — voila! You now have a cryptographically signed attestation of your SBOM.&lt;/p>
&lt;p>At sbomify, we are big fans of dogfooding our own product, so we&amp;rsquo;ve adopted this exact flow in the SBOM we generate for our GitHub Actions module itself, as you can see &lt;a href="https://github.com/sbomify/github-action/blob/master/.github/workflows/sbomify.yaml">here&lt;/a>.&lt;/p>
&lt;p>The job looks something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">...]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Upload SBOM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">sbomify/github-action@master&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">TOKEN&lt;/span>: &lt;span style="color:#ae81ff">${{ secrets.SBOMIFY_TOKEN }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">COMPONENT_ID&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;Gu9wem8mkX&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">LOCK_FILE&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;poetry.lock&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">COMPONENT_NAME&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;sbomify-github-action&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">COMPONENT_VERSION&lt;/span>: &lt;span style="color:#ae81ff">${{ github.ref_name }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">AUGMENT&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ENRICH&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">UPLOAD&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">OUTPUT_FILE&lt;/span>: &lt;span style="color:#ae81ff">github-action.cdx.json&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Attest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/attest-build-provenance@v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">subject-path&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;${{ github.workspace }}/github-action.cdx.json&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For more details on using the GitHub Action and other CI/CD integrations, see our &lt;a href="https://sbomify.com/features/integrations/">integrations page&lt;/a>.&lt;/p>
&lt;p>What’s great about this is that it removes the need to trust sbomify directly. You can verify the SBOM independently as follows:&lt;/p>
&lt;ul>
&lt;li>Download the latest SBOM from the GitHub Action &lt;a href="https://app.sbomify.com/component/Gu9wem8mkX">sbomify public page&lt;/a>&lt;/li>
&lt;li>Install the GitHub CLI if you don&amp;rsquo;t already have it&lt;/li>
&lt;/ul>
&lt;p>With this done, you can verify the file against GitHub:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ gh attestation verify path/to/downloaded-sbom.json --owner sbomify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Loaded digest sha256:aeee57eeb5b34e0f70ace59bfc2328e3332062523796837eb37883eb805cd8f9 &lt;span style="color:#66d9ef">for&lt;/span> file:///path/to/downloaded-sbom.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Loaded &lt;span style="color:#ae81ff">1&lt;/span> attestation from GitHub API
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>✓ Verification succeeded!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sha256:aeee57eeb5b34e0f70ace59bfc2328e3332062523796837eb37883eb805cd8f9 was attested by:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>REPO PREDICATE_TYPE WORKFLOW
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sbomify/github-action https://slsa.dev/provenance/v1 .github/workflows/sbomify.yaml@refs/tags/v0.1.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And just like that! We can independently verify that sbomify (or any other intermediary) did not tamper with the SBOM in transit.&lt;/p></description><category>announcement</category></item><item><title>How to generate an SBOM from a Docker container</title><link>https://sbomify.com/2024/09/20/how-to-generate-an-sbom-from-a-container/</link><pubDate>Fri, 20 Sep 2024 00:00:00 +0000</pubDate><guid>https://sbomify.com/2024/09/20/how-to-generate-an-sbom-from-a-container/</guid><description>&lt;p>A lot of people are asking about how one can generate an SBOM based on a Docker container. It seems to be a good idea, since a lot of modern software is shipped in Docker containers, so it&amp;rsquo;s completely understandable why this is appealing.&lt;/p>
&lt;h2 id="why-you-shouldnt-generate-an-sbom-from-a-docker-container">Why You Shouldn&amp;rsquo;t Generate an SBOM from a Docker Container&lt;/h2>
&lt;p>Before we dive into &lt;em>how&lt;/em> to generate an SBOM from a Docker container, let&amp;rsquo;s first talk about why you shouldn&amp;rsquo;t do it this way. Or rather, what the limitations of generating an SBOM from a Docker container are.&lt;/p>
&lt;p>Generally speaking, Docker containers will come with a set of system packages and runtime dependencies. Once you&amp;rsquo;ve installed your dependencies, you usually have a final step where you copy in your actual application codebase. There are, of course, countless exceptions to this (and multi-stage builds make things even murkier).&lt;/p>
&lt;p>Now, capturing the system packages and runtime dependencies from a Docker container (assuming you&amp;rsquo;re not using an obscure flavor) is a fairly straightforward task. If you go to our &lt;a href="https://sbomify.com/resources/">resources&lt;/a>, you can find a few tools that can do this well. Perhaps the most popular ones at the time of this writing ar Syft and Trivy. In our &lt;a href="https://github.com/sbomify/sbom-benchmarks">sbom-benchmark&lt;/a> repository, you can see that both of these jobs do a good job in capturing this.&lt;/p>
&lt;p>The problem is not with these packages, but rather what happens in the following layers. For instance, if you copy in a binary of sorts into your Docker container, more or less no SBOM generation tool will be able to capture this. This is because the tools usually are looking at the system package database to construct the list. If this list is incomplete (e.g. you&amp;rsquo;re copying in a binary), or tampered with, none of these tools will pick it up.&lt;/p>
&lt;p>Tools like Syft and Trivy are however pretty good at picking up installed packages from various programming languages, but the quality will vary from language to language.&lt;/p>
&lt;p>You have been warned. Proceed with caution.&lt;/p>
&lt;p>Our recommendation is to separate the container SBOM from the application SBOM. This way you use more customized tooling in order to achieve a more accurate SBOM.&lt;/p>
&lt;h2 id="how-to-generate-an-sbom-form-a-container-image">How to generate an SBOM form a container image&lt;/h2>
&lt;p>You can find a number of tools on our &lt;a href="https://sbomify.com/resources/">resources&lt;/a> page that can be used for generating SBOMs. Let&amp;rsquo;s go though one-by-one how to do this. You can find a complete example in our &lt;a href="https://github.com/sbomify/sbom-benchmarks">sbom-benchmark&lt;/a> repository.&lt;/p>
&lt;h3 id="syft">Syft&lt;/h3>
&lt;p>You first need to install &lt;a href="https://github.com/anchore/syft">Syft&lt;/a>, and then run it with the following command:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ syft &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> nginx:stable &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -o cyclonedx-json &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> &amp;gt; syft.cdx.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will generate an SBOM in CycloneDX format, and save it to &lt;code>syft.cdx.json&lt;/code>.&lt;/p>
&lt;p>Would you rather generate a SPDX SBOM, you can do this by running:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ syft &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> nginx:stable &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -o spdx-json &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> &amp;gt; syft.spdx.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="trivy">Trivy&lt;/h3>
&lt;p>You can download &lt;a href="https://github.com/aquasecurity/trivy">Trivy&lt;/a>, and then run it with the following command to generate an SBOM in CycloneDX format, and save it to &lt;code>trivy.cdx.json&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ trivy image &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --format cyclonedx &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --output trivy.cdx.json &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> nginx:stable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Would you rather generate a SPDX SBOM, you can do this by running:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ trivy image &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --format spdx-json &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --output trivy.spdx.json &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> nginx:stable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="docker-desktop">Docker Desktop&lt;/h3>
&lt;p>If you have Docker Desktop installed, you can also use this to generate an SBOM in SPDX format, and save it to &lt;code>docker.spdx.json&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ docker sbom &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> –-format spdx-json &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> nginx:stable &amp;gt; docker.spdx.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>It&amp;rsquo;s worth noting that Docker is largely using Syft behind the scene. Docker is doing some extra things, but it also is more restrictive in output formats. We covered more about this in &lt;a href="https://sbomify.com/2024/04/07/how-to-create-an-sbom/">this blog post&lt;/a>.&lt;/p>
&lt;h3 id="sbomify-action">sbomify action&lt;/h3>
&lt;p>You can also use the &lt;a href="https://github.com/marketplace/actions/sbomify">sbomify SBOM Generation tool&lt;/a> directly in GitHub as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Upload SBOM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">sbomify/github-action@master&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">TOKEN&lt;/span>: &lt;span style="color:#ae81ff">${{ secrets.SBOMIFY_TOKEN }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">COMPONENT_ID&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;my-component-id&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">DOCKER_IMAGE&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;nginx:stable&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">COMPONENT_NAME&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;nginx-container&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">COMPONENT_VERSION&lt;/span>: &lt;span style="color:#ae81ff">${{ github.ref_name }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">AUGMENT&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ENRICH&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For more details on using the GitHub Action and other CI/CD integrations, see our &lt;a href="https://sbomify.com/features/integrations/">integrations page&lt;/a>.&lt;/p></description><category>guide</category></item><item><title>Get the latest SBOMs from the top 15 most popular images on Docker Hub</title><link>https://sbomify.com/2024/06/04/get-the-latest-sboms-from-the-top-15-most-popular-images-on-docker-hub/</link><pubDate>Tue, 04 Jun 2024 14:52:07 +0200</pubDate><guid>https://sbomify.com/2024/06/04/get-the-latest-sboms-from-the-top-15-most-popular-images-on-docker-hub/</guid><description>&lt;p>Most companies that use Docker also use Docker Hub in some capacity. Have you ever wondered how secure these images are? In our article &lt;a href="https://sbomify.com/2024/05/27/comprehensive-guide-to-generating-and-understanding-sboms-with-docker-and-django-cms/">Comprehensive Guide to Generating and Understanding SBOMs with Docker and Django-CMS&lt;/a>, we talked about how to generate SBOMs from a Docker image.&lt;/p>
&lt;p>In this article, we are taking this one step further and automating the process in our CI/CD pipeline (in this case &lt;a href="https://docs.github.com/en/actions">GitHub Actions&lt;/a>). We&amp;rsquo;ve created a GitHub repository called &lt;a href="https://github.com/sbomify/docker-hub-sbom">docker-hub-sbom&lt;/a> that automatically builds SBOMs for the top 15 Docker Hub images every night.&lt;/p>
&lt;p>The top 15 most popular (official) Docker images are as follows:&lt;/p>
&lt;ul>
&lt;li>alpine&lt;/li>
&lt;li>busybox&lt;/li>
&lt;li>docker&lt;/li>
&lt;li>hello-world&lt;/li>
&lt;li>httpd&lt;/li>
&lt;li>memcached&lt;/li>
&lt;li>mongo&lt;/li>
&lt;li>mysql&lt;/li>
&lt;li>nginx&lt;/li>
&lt;li>node&lt;/li>
&lt;li>postgres&lt;/li>
&lt;li>python&lt;/li>
&lt;li>rabbitmq&lt;/li>
&lt;li>redis&lt;/li>
&lt;li>ubuntu&lt;/li>
&lt;/ul>
&lt;p>To keep things simple, we will only generate the SBOM for the &amp;rsquo;latest&amp;rsquo; tag of each disk image.&lt;/p>
&lt;p>Unlike in our previous guide, we will not use the &lt;code>docker sbom&lt;/code> feature available in Docker Desktop. Instead, we will use the tool that Docker Desktop uses behind the scenes, namely &lt;a href="https://github.com/anchore/syft">syft&lt;/a>.&lt;/p>
&lt;p>The full CI/CD pipeline is defined in &lt;a href="https://github.com/sbomify/docker-hub-sbom/blob/master/.github/workflows/build-sboms.yml">build-sboms.yml&lt;/a>, but in simple terms, all it does is iterate over the list of images and then use &lt;code>syft&lt;/code> to build an SBOM both in CycloneDX and SPDX format.&lt;/p>
&lt;p>After each run has been successful, it publishes the SBOMs as artifacts. You can see an example of this in &lt;a href="https://github.com/sbomify/docker-hub-sbom/actions/runs/9359480735">this run&lt;/a>. For instance, you can download the SBOM for nginx (&lt;a href="https://github.com/sbomify/docker-hub-sbom/actions/runs/9359480735/artifacts/1564889381">CycloneDX&lt;/a> and &lt;a href="https://github.com/sbomify/docker-hub-sbom/actions/runs/9359480735/artifacts/1564889383">SPDX&lt;/a>).&lt;/p>
&lt;p>There are a few important things to point out here:&lt;/p>
&lt;ul>
&lt;li>First, this way of generating SBOMs is completely CI/CD agnostic. You could easily take this workflow and implement it on other tools like &lt;a href="https://www.travis-ci.com/">Travis&lt;/a>, &lt;a href="https://www.jenkins.io/">Jenkins&lt;/a>, &lt;a href="https://www.jetbrains.com/teamcity/">TeamCity&lt;/a> or almost any other CI/CD platform.&lt;/li>
&lt;li>Second, while we are using upstream Docker Hub images in this example, you could just swap this out for your own internal Docker images for your application and get the same result.&lt;/li>
&lt;/ul></description><category>news</category></item><item><title>Comprehensive Guide to Generating and Understanding SBOMs with Docker and Django-CMS</title><link>https://sbomify.com/2024/05/27/comprehensive-guide-to-generating-and-understanding-sboms-with-docker-and-django-cms/</link><pubDate>Mon, 27 May 2024 16:18:25 +0200</pubDate><guid>https://sbomify.com/2024/05/27/comprehensive-guide-to-generating-and-understanding-sboms-with-docker-and-django-cms/</guid><description>&lt;p>It&amp;rsquo;s fair to say that SBOMs (Software Bill of Materials) is a rapidly emerging field. Many vendors, like Docker and GitHub, now offer tools to automatically generate SBOMs for you. That&amp;rsquo;s great, but maybe we should first start by asking ourselves what should really go into an SBOM.&lt;/p>
&lt;p>The simplest answer to this question is that it should include everything that makes up your software. Thus, things like dependencies (such as open source libraries used) should go into the SBOM. This is where it gets a bit murkier.&lt;/p>
&lt;p>What about dependencies that you&amp;rsquo;re only using for testing, such as a unit test library? This is never used in the production environment, so it&amp;rsquo;s more like a soft dependency.&lt;/p>
&lt;p>But what about your runtime environment? If you&amp;rsquo;re using a dockerized runtime environment, it&amp;rsquo;s relatively easy to determine what&amp;rsquo;s part of your application stack, but less so if you&amp;rsquo;re running on bare metal or in a Virtual Machine (VM). You could argue that you need to generate an SBOM from your Infrastructure-as-Code (IaC), such as Terraform/OpenTofu or Ansible, which holds the truths about your runtime environment. That is, assuming you even pin the releases of all of this.&lt;/p>
&lt;p>It&amp;rsquo;s also important to point out that an SBOM is not an absolute truth for a product. It&amp;rsquo;s just true at the time of generation and might change the next time you fire off a build in your CI/CD pipeline. This largely depends on how strictly you pin your dependencies (and how strictly your dependencies pin their dependencies). It is, however, important to stress that SBOM generation needs to be part of your CI/CD pipeline to be relevant.&lt;/p>
&lt;p>Your mileage may vary, but to keep things simple, for the sake of this article, let&amp;rsquo;s focus on the &amp;lsquo;hard dependencies,&amp;rsquo; meaning things that are required for your software to work. Let&amp;rsquo;s also assume that your application is running in Docker to keep things simple and that everything that goes inside your Dockerfile is a hard requirement.&lt;/p>
&lt;p>A project can, of course, span multiple services (e.g., microservices), but let&amp;rsquo;s again keep things simple and focus on a single monolith application that lives inside a single Docker container.&lt;/p>
&lt;h3 id="an-example-project-django-cms">An Example Project: Django-CMS&lt;/h3>
&lt;p>To make things more realistic, let&amp;rsquo;s use the open-source project &lt;a href="https://github.com/django-cms/django-cms/">Django CMS&lt;/a> and their &lt;a href="https://github.com/django-cms/django-cms-quickstart">Django CMS Quickstart&lt;/a> as the basis for our exploration.&lt;/p>
&lt;p>Taking a closer look at this example, we will find a &lt;code>requirements.txt&lt;/code> file as expected for a Python project. There are several tools we can use to generate an SBOM for this file, including &lt;a href="https://github.com/CycloneDX/cyclonedx-python">cyclonedx-python&lt;/a>, which will generate an SBOM in CycloneDX format:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cyclonedx-py requirements &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> requirements.txt &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -o sbom.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>There are other tools, like &lt;a href="https://github.com/opensbom-generator/spdx-sbom-generator">spdx-sbom-generator&lt;/a>, that can generate SBOMs in SPDX format (rather than CycloneDX as we used above).&lt;/p>
&lt;p>Now that we have our SBOM for the application layer, we can move on to the &lt;code>Dockerfile&lt;/code> to build an SBOM for our Docker environment. We can do this as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ docker build . -t django-cms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>...&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker sbom &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --format cyclonedx-json &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -o docker-sbom.json &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> django-cms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we have two files:&lt;/p>
&lt;ul>
&lt;li>&lt;code>sbom.json&lt;/code>&lt;/li>
&lt;li>&lt;code>docker-sbom.json&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Let&amp;rsquo;s take a look at them:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ wc -l sbom.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1053&lt;/span> sbom.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ wc -l docker-sbom.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">48162&lt;/span> docker-sbom.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Whoa! The first SBOM is just over 1,000 lines, whereas the one from Docker is ~48 times that size. Why is that? As it turns out, Docker will actually do more than just give you information about the runtime. In fact, it gives you an SBOM for the runtime and your application stack. Under the hood, &lt;code>docker sbom&lt;/code> uses &lt;a href="https://github.com/anchore/syft">syft&lt;/a>, which is capable of generating SBOMs for Python too. Thus, we can disregard our first SBOM.&lt;/p>
&lt;p>The elegant thing about extracting our SBOM from a Docker container over a &lt;code>requirements.txt&lt;/code> file is that assuming we are building our Docker containers correctly and not bundling our test dependencies in there, we have solved for this in the process.&lt;/p>
&lt;h3 id="but-wait-what-about-sub-dependencies">But wait, what about sub-dependencies?&lt;/h3>
&lt;p>Fantastic question! If we go back to django-cms, we notice that there is a dependency outside of Python by the presence of &lt;a href="https://github.com/django-cms/django-cms/blob/develop-4/package.json">&lt;code>package.json&lt;/code>&lt;/a> (and &lt;code>package-lock.json&lt;/code>). If we randomly pick a dependency in there (such as babel-runtime), we can indeed prove that this is missing:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ grep babel-runtime docker-sbom.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>...&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is where it gets tricky. If there is a vulnerability in this package, a surface-level exploration of the SBOM with a tool like &lt;a href="https://osv.dev/">osv-scanner&lt;/a> would not pick up on this. This is generally known as transitive dependencies. To address this, we need to &amp;ldquo;explode&amp;rdquo; the SBOM, but that&amp;rsquo;s outside the scope of this article.&lt;/p></description><category>guide</category></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sbomify</title><link>https://sbomify.com/tags/supply-chain/</link><description>Your Security Artifact Hub. From zero to SBOM hero. Generate, manage, and share SBOMs and compliance documents. Built for CRA compliance and seamless integration with your existing tools.</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 29 Jan 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://sbomify.com/tags/supply-chain/" rel="self" type="application/rss+xml"/><item><title>What Is a Dependency in Software? A Beginner&amp;#39;s Guide</title><link>https://sbomify.com/2026/01/29/what-is-a-dependency-in-software/</link><pubDate>Thu, 29 Jan 2026 00:00:00 +0000</pubDate><guid>https://sbomify.com/2026/01/29/what-is-a-dependency-in-software/</guid><description>&lt;p>A dependency in software is any external component — a library, framework, module, or package — that your application relies on to function. When you import a package from npm, add a library from PyPI, or include a Maven artifact, you are adding a dependency. Dependencies allow developers to reuse tested, maintained code rather than writing everything from scratch. Modern applications are built overwhelmingly from dependencies: studies consistently show that &lt;a href="https://www.linux.com/training-tutorials/estimating-total-number-linux-contributors-approach-using-linus-law/">70-90% of a typical application consists of open source components&lt;/a>.&lt;/p>
&lt;h2 id="direct-vs-transitive-dependencies">Direct vs. Transitive Dependencies&lt;/h2>
&lt;p>The most important distinction in dependency management is between direct and transitive dependencies.&lt;/p>
&lt;p>&lt;strong>Direct dependencies&lt;/strong> are the packages your project explicitly declares. These appear in your dependency manifest — &lt;code>package.json&lt;/code> for JavaScript, &lt;code>requirements.txt&lt;/code> or &lt;code>pyproject.toml&lt;/code> for Python, &lt;code>pom.xml&lt;/code> for Java, &lt;code>go.mod&lt;/code> for Go, &lt;code>Cargo.toml&lt;/code> for Rust, and similar files for other ecosystems. You chose these packages, you decided which versions to use, and you are (presumably) aware of their purpose in your application.&lt;/p>
&lt;p>&lt;strong>Transitive dependencies&lt;/strong> are the dependencies of your dependencies. When you add package A to your project, and package A depends on packages B and C, and package B depends on package D, then B, C, and D are all transitive dependencies of your project. You may never have heard of packages B, C, or D, yet they are running in your application and their vulnerabilities are your vulnerabilities.&lt;/p>
&lt;h3 id="the-scale-of-transitive-dependencies">The Scale of Transitive Dependencies&lt;/h3>
&lt;p>The ratio of transitive to direct dependencies is often surprising:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Ecosystem&lt;/th>
&lt;th>Typical direct dependencies&lt;/th>
&lt;th>Typical total (including transitive)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>JavaScript&lt;/td>
&lt;td>20-50&lt;/td>
&lt;td>200-1,500+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Python&lt;/td>
&lt;td>10-30&lt;/td>
&lt;td>50-200&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Java/Maven&lt;/td>
&lt;td>10-30&lt;/td>
&lt;td>100-500&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Go&lt;/td>
&lt;td>10-30&lt;/td>
&lt;td>50-300&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Rust/Cargo&lt;/td>
&lt;td>10-30&lt;/td>
&lt;td>100-400&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>A JavaScript project with 30 direct dependencies may pull in over 1,000 transitive packages through the npm dependency tree. Each of those packages is code running in your application, with its own maintenance status, license, and vulnerability history.&lt;/p>
&lt;h2 id="the-dependency-tree">The Dependency Tree&lt;/h2>
&lt;p>A dependency tree (or dependency graph) is the complete set of relationships between a project and all of its dependencies, both direct and transitive. Visualizing this tree reveals the full scope of what your application depends on.&lt;/p>
&lt;pre tabindex="0">&lt;code>my-application
├── express@4.18.2 (direct)
│ ├── body-parser@1.20.2 (transitive)
│ │ ├── bytes@3.1.2
│ │ └── iconv-lite@0.4.24
│ │ └── safer-buffer@2.1.2
│ ├── cookie@0.5.0
│ └── ...
├── lodash@4.17.21 (direct)
└── axios@1.6.2 (direct)
└── follow-redirects@1.15.3 (transitive)
&lt;/code>&lt;/pre>&lt;p>In this example, &lt;code>express&lt;/code>, &lt;code>lodash&lt;/code>, and &lt;code>axios&lt;/code> are direct dependencies. Everything nested beneath them is transitive. The vulnerability in &lt;code>safer-buffer&lt;/code> — four levels deep — is just as dangerous as one in &lt;code>express&lt;/code> itself.&lt;/p>
&lt;h2 id="why-dependencies-matter-for-security">Why Dependencies Matter for Security&lt;/h2>
&lt;p>Dependencies are the primary attack surface for most applications. Several high-profile incidents illustrate the risks:&lt;/p>
&lt;h3 id="vulnerable-dependencies">Vulnerable Dependencies&lt;/h3>
&lt;p>The &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-44228">Log4Shell vulnerability&lt;/a> (&lt;a href="https://sbomify.com/2025/12/18/cve-vulnerability-explained/">CVE-2021-44228&lt;/a>) in the Apache Log4j logging library affected millions of Java applications. Many organizations did not know they used Log4j because it was a transitive dependency — pulled in by frameworks and libraries they did depend on directly.&lt;/p>
&lt;h3 id="compromised-dependencies">Compromised Dependencies&lt;/h3>
&lt;p>The &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2024-3094">XZ Utils backdoor&lt;/a> demonstrated that attackers can spend years gaining trust in a legitimate open source project before inserting malicious code. When a dependency is compromised, every application that uses it is affected.&lt;/p>
&lt;h3 id="abandoned-dependencies">Abandoned Dependencies&lt;/h3>
&lt;p>Dependencies that are no longer maintained represent a growing risk. When a &lt;a href="https://sbomify.com/2025/12/18/cve-vulnerability-explained/">CVE&lt;/a> is found in an unmaintained package, there may be no one to produce a patch. The component stays vulnerable indefinitely unless consumers fork it or find an alternative.&lt;/p>
&lt;h3 id="dependency-confusion">Dependency Confusion&lt;/h3>
&lt;p>Dependency confusion attacks exploit the way package managers resolve names. An attacker publishes a malicious package to a public registry with the same name as a private internal package. If the package manager checks the public registry first (or alongside) the private one, it may install the attacker&amp;rsquo;s package instead.&lt;/p>
&lt;p>For a deeper discussion of supply chain attacks, see our &lt;a href="https://sbomify.com/2025/12/26/software-supply-chain-management/">software supply chain management guide&lt;/a>.&lt;/p>
&lt;h2 id="lock-files">Lock Files&lt;/h2>
&lt;p>Lock files are a critical tool for dependency management. They record the exact versions of every dependency (direct and transitive) that were resolved during installation, ensuring that subsequent installations produce identical results.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Ecosystem&lt;/th>
&lt;th>Lock File&lt;/th>
&lt;th>Manifest File&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>JavaScript&lt;/td>
&lt;td>&lt;code>package-lock.json&lt;/code>&lt;/td>
&lt;td>&lt;code>package.json&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Python&lt;/td>
&lt;td>&lt;code>poetry.lock&lt;/code>&lt;/td>
&lt;td>&lt;code>pyproject.toml&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Rust&lt;/td>
&lt;td>&lt;code>Cargo.lock&lt;/code>&lt;/td>
&lt;td>&lt;code>Cargo.toml&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Go&lt;/td>
&lt;td>&lt;code>go.sum&lt;/code>&lt;/td>
&lt;td>&lt;code>go.mod&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ruby&lt;/td>
&lt;td>&lt;code>Gemfile.lock&lt;/code>&lt;/td>
&lt;td>&lt;code>Gemfile&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PHP&lt;/td>
&lt;td>&lt;code>composer.lock&lt;/code>&lt;/td>
&lt;td>&lt;code>composer.json&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Without a lock file, the same manifest can resolve to different dependency versions on different machines or at different times. This non-determinism is both a reliability risk (builds may break unpredictably) and a security risk (a newly published malicious version could be pulled in automatically).&lt;/p>
&lt;p>Lock files should always be committed to version control. They are the source of truth for what is actually installed in your project.&lt;/p>
&lt;h2 id="how-sboms-document-dependencies">How SBOMs Document Dependencies&lt;/h2>
&lt;p>A &lt;a href="https://sbomify.com/what-is-sbom/">Software Bill of Materials&lt;/a> provides a complete, machine-readable inventory of every component in your software, including all transitive dependencies. This is essential for security because:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Full visibility.&lt;/strong> An SBOM documents every package in the dependency tree, not just the direct dependencies listed in your manifest file. This is the only reliable way to know everything running in your application.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Vulnerability matching.&lt;/strong> Once you have an SBOM, platforms like &lt;a href="https://sbomify.com">sbomify&lt;/a> can continuously monitor every component against vulnerability databases. CLI tools like &lt;a href="https://github.com/anchore/grype">Grype&lt;/a> and &lt;a href="https://google.github.io/osv-scanner/">OSV-Scanner&lt;/a> provide point-in-time scanning, while &lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a> offers standalone continuous monitoring. See our &lt;a href="https://sbomify.com/2026/02/01/sbom-scanning-vulnerability-detection/">SBOM scanning guide&lt;/a> for details and our &lt;a href="https://sbomify.com/resources/">resources page&lt;/a> for a complete list of tools.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Dependency relationship mapping.&lt;/strong> Both &lt;a href="https://cyclonedx.org/">CycloneDX&lt;/a> and &lt;a href="https://spdx.dev/">SPDX&lt;/a> support dependency relationship data, documenting which components depend on which others. This lets you trace the path from a vulnerable transitive dependency back to the direct dependency that brought it in.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>License tracking.&lt;/strong> Each dependency carries a license. SBOMs document these licenses, enabling automated compliance checking. A single &lt;a href="https://sbomify.com/2025/12/22/gpl-license-guide/">GPL-licensed&lt;/a> transitive dependency can trigger copyleft obligations for your entire application.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>SBOM generation tools like the &lt;a href="https://github.com/sbomify/github-action/">sbomify GitHub Action&lt;/a>, &lt;a href="https://github.com/anchore/syft">Syft&lt;/a>, and &lt;a href="https://github.com/aquasecurity/trivy">Trivy&lt;/a> analyze lock files and build artifacts to capture the full dependency tree. For language-specific SBOM generation instructions, see our &lt;a href="https://sbomify.com/guides/">SBOM guides&lt;/a>.&lt;/p>
&lt;h2 id="best-practices">Best Practices&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Always use and commit lock files.&lt;/strong> Lock files ensure reproducible builds and prevent unexpected dependency changes. Review lock file diffs in pull requests to catch unintended dependency updates.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Audit your dependency tree regularly.&lt;/strong> Use &lt;code>npm audit&lt;/code>, &lt;code>pip-audit&lt;/code>, &lt;code>cargo audit&lt;/code>, or equivalent tools to check for known vulnerabilities. Do not limit auditing to direct dependencies — transitive vulnerabilities are equally dangerous.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Minimize your dependency footprint.&lt;/strong> Every dependency is a potential risk vector. Before adding a new package, evaluate whether the functionality justifies the added surface area. Prefer well-maintained libraries with active security response processes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Generate and monitor SBOMs.&lt;/strong> Automate SBOM generation in your CI/CD pipeline and monitor SBOMs continuously against vulnerability databases. This catches newly disclosed CVEs in your existing dependencies. See our &lt;a href="https://sbomify.com/2026/01/18/sbom-management-best-practices/">SBOM management guide&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Keep dependencies up to date.&lt;/strong> Apply security updates promptly, especially for dependencies listed in the &lt;a href="https://sbomify.com/2025/12/30/what-is-kev-cisa-known-exploited-vulnerabilities/">CISA KEV catalog&lt;/a>. Use tools like Dependabot or Renovate to automate update pull requests.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Review dependency changes.&lt;/strong> Treat dependency updates in pull requests with the same scrutiny as code changes. A bumped version may introduce new transitive dependencies, change licenses, or include unexpected modifications.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="frequently-asked-questions">Frequently Asked Questions&lt;/h2>
&lt;h3 id="what-is-a-dependency-in-software">What is a dependency in software?&lt;/h3>
&lt;p>A dependency is any external component — a library, framework, module, or package — that your application relies on to function. Dependencies are declared in manifest files (like &lt;code>package.json&lt;/code> or &lt;code>requirements.txt&lt;/code>) and installed from package registries (like npm or PyPI). They allow developers to reuse existing code rather than building everything from scratch.&lt;/p>
&lt;h3 id="what-is-a-transitive-dependency">What is a transitive dependency?&lt;/h3>
&lt;p>A transitive dependency is a dependency of your dependency. If your project depends on package A, and package A depends on package B, then B is a transitive dependency of your project. Transitive dependencies are often invisible to developers but can contain vulnerabilities, restrictive licenses, or outdated code. They typically outnumber direct dependencies by a factor of 5-30x depending on the ecosystem.&lt;/p>
&lt;h3 id="what-is-a-dependency-tree">What is a dependency tree?&lt;/h3>
&lt;p>A dependency tree (or dependency graph) is the complete hierarchy of all dependencies in a project, showing both direct and transitive relationships. It reveals the full set of code that your application actually uses at runtime. SBOM generation tools analyze dependency trees to produce complete component inventories.&lt;/p>
&lt;h3 id="why-are-dependencies-a-security-risk">Why are dependencies a security risk?&lt;/h3>
&lt;p>Dependencies are a security risk because each one introduces code that your team did not write and may not audit. Known vulnerabilities in dependencies (CVEs) are a primary attack vector — incidents like Log4Shell affected millions of applications through a single widely-used library. Dependencies can also be intentionally compromised (as in the XZ Utils backdoor), abandoned by maintainers, or used in dependency confusion attacks.&lt;/p>
&lt;h3 id="what-is-a-lock-file">What is a lock file?&lt;/h3>
&lt;p>A lock file records the exact resolved versions of all dependencies (direct and transitive) in a project. Examples include &lt;code>package-lock.json&lt;/code> (npm), &lt;code>poetry.lock&lt;/code> (Python), and &lt;code>Cargo.lock&lt;/code> (Rust). Lock files ensure reproducible builds — the same versions are installed every time, on every machine. They should always be committed to version control.&lt;/p></description><category>education</category></item><item><title>Software Supply Chain Management: Risks, Best Practices, and SBOM Integration</title><link>https://sbomify.com/2025/12/26/software-supply-chain-management/</link><pubDate>Fri, 26 Dec 2025 00:00:00 +0000</pubDate><guid>https://sbomify.com/2025/12/26/software-supply-chain-management/</guid><description>&lt;p>Software supply chain management is the practice of identifying, assessing, and mitigating risks across the entire chain of components, tools, and processes used to develop and deliver software. A software supply chain encompasses everything that contributes to a finished application: open source libraries, third-party services, build tools, package registries, CI/CD pipelines, and the people and processes that connect them. Managing this chain is essential because a vulnerability or compromise at any point can propagate downstream to every consumer of the software.&lt;/p>
&lt;p>&lt;img src="https://sbomify.com/assets/images/d2/supply-chain-risk.svg" alt="Software supply chain from upstream dependencies through build to downstream consumers">&lt;/p>
&lt;h2 id="what-is-a-software-supply-chain">What Is a Software Supply Chain?&lt;/h2>
&lt;p>A software supply chain is the complete set of components, dependencies, tools, and workflows involved in creating, building, and distributing a piece of software. Just as a physical supply chain traces the path of raw materials through manufacturing to a finished product, a software supply chain traces the path of code from its origins to its deployment.&lt;/p>
&lt;p>Modern applications are overwhelmingly assembled rather than written from scratch. Studies consistently show that &lt;a href="https://www.linux.com/training-tutorials/estimating-total-number-linux-contributors-approach-using-linus-law/">70-90% of a typical application consists of open source components&lt;/a> drawn from public package registries like npm, PyPI, Maven Central, and crates.io. Each of these components has its own dependencies, creating a deep tree of transitive dependencies that most development teams never manually audit.&lt;/p>
&lt;p>This reality makes software supply chain risk management (SSCRM) a critical discipline. If a single component in your dependency tree is compromised, vulnerable, or abandoned, the risk flows directly into your application and to your users.&lt;/p>
&lt;h2 id="chain-of-custody-in-software">Chain of Custody in Software&lt;/h2>
&lt;p>Chain of custody is a concept borrowed from forensics and physical supply chains. In the software context, chain of custody refers to the documented trail that records who created, modified, built, and distributed each component in a software product. A robust chain of custody answers questions like:&lt;/p>
&lt;ul>
&lt;li>Where did this component originate?&lt;/li>
&lt;li>Who authored and maintained it?&lt;/li>
&lt;li>Was it modified between the source repository and the package registry?&lt;/li>
&lt;li>Was the build process reproducible and tamper-evident?&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://sbomify.com/what-is-sbom/">Software Bills of Materials&lt;/a> (SBOMs) provide the component-level inventory that underpins chain of custody. Frameworks like &lt;a href="https://sbomify.com/2024/08/17/what-is-slsa/">SLSA&lt;/a> (Supply-chain Levels for Software Artifacts) and &lt;a href="https://in-toto.io/">in-toto&lt;/a> add attestation layers that cryptographically verify each step in the build process.&lt;/p>
&lt;h2 id="major-software-supply-chain-attacks">Major Software Supply Chain Attacks&lt;/h2>
&lt;p>Several high-profile incidents have demonstrated the consequences of supply chain compromise.&lt;/p>
&lt;h3 id="solarwinds-2020">SolarWinds (2020)&lt;/h3>
&lt;p>Attackers compromised the build system of SolarWinds&amp;rsquo; Orion IT monitoring platform, injecting malicious code into a routine software update. Approximately 18,000 organizations, including U.S. government agencies, installed the compromised update. The attack was attributed to a state-sponsored actor and went undetected for months. It demonstrated that compromising a single widely-used vendor can provide access to thousands of downstream organizations.&lt;/p>
&lt;h3 id="log4shell-2021">Log4Shell (2021)&lt;/h3>
&lt;p>&lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-44228">CVE-2021-44228&lt;/a>, known as Log4Shell, was a critical remote code execution vulnerability in Apache Log4j, a ubiquitous Java logging library. The vulnerability affected millions of applications worldwide. Organizations without component inventories struggled for weeks to determine whether they were affected. This incident became the single most cited argument for SBOM adoption: organizations with SBOMs could identify affected systems in minutes.&lt;/p>
&lt;h3 id="xz-utils-backdoor-2024">XZ Utils Backdoor (2024)&lt;/h3>
&lt;p>&lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2024-3094">CVE-2024-3094&lt;/a> revealed a deliberately planted backdoor in the XZ Utils compression library, a component present in virtually every Linux distribution. A malicious contributor spent years building trust in the project before inserting the backdoor. This attack showed that supply chain risks include not just accidental vulnerabilities but intentional sabotage through social engineering of open source maintainers.&lt;/p>
&lt;h3 id="common-attack-vectors">Common Attack Vectors&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Attack Vector&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Example&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Build system compromise&lt;/strong>&lt;/td>
&lt;td>Injecting malicious code during the build/CI process&lt;/td>
&lt;td>SolarWinds&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Dependency confusion&lt;/strong>&lt;/td>
&lt;td>Publishing malicious packages with names that overlap internal packages&lt;/td>
&lt;td>Multiple incidents across npm, PyPI&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Typosquatting&lt;/strong>&lt;/td>
&lt;td>Publishing packages with names similar to popular libraries&lt;/td>
&lt;td>Thousands of examples across registries&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Maintainer compromise&lt;/strong>&lt;/td>
&lt;td>Gaining control of a legitimate package through social engineering&lt;/td>
&lt;td>XZ Utils&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Vulnerable dependency&lt;/strong>&lt;/td>
&lt;td>Exploiting a known vulnerability in a widely-used component&lt;/td>
&lt;td>Log4Shell&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="software-supply-chain-risk-management-frameworks">Software Supply Chain Risk Management Frameworks&lt;/h2>
&lt;p>Several frameworks provide structured approaches to managing software supply chain risk.&lt;/p>
&lt;h3 id="nist-c-scrm-sp-800-161-rev-1">NIST C-SCRM (SP 800-161 Rev 1)&lt;/h3>
&lt;p>&lt;a href="https://csrc.nist.gov/pubs/sp/800/161/r1/final">NIST SP 800-161 Rev 1&lt;/a> (&amp;ldquo;Cybersecurity Supply Chain Risk Management Practices for Systems and Organizations&amp;rdquo;) provides the most comprehensive federal guidance on supply chain risk. It builds on the &lt;a href="https://sbomify.com/compliance/nist-800-53/">NIST SP 800-53&lt;/a> control framework, particularly the SR (Supply Chain Risk Management) family, and provides detailed practices for identifying, assessing, and mitigating supply chain risks throughout the system development life cycle.&lt;/p>
&lt;h3 id="executive-order-14028">Executive Order 14028&lt;/h3>
&lt;p>&lt;a href="https://sbomify.com/compliance/eo-14028/">Executive Order 14028&lt;/a> (&amp;ldquo;Improving the Nation&amp;rsquo;s Cybersecurity&amp;rdquo;, 2021) directed federal agencies to enhance software supply chain security, including requiring SBOMs from software vendors and establishing the &lt;a href="https://sbomify.com/compliance/ntia-minimum-elements/">NTIA minimum elements&lt;/a> for SBOM content.&lt;/p>
&lt;h3 id="eu-cyber-resilience-act">EU Cyber Resilience Act&lt;/h3>
&lt;p>The &lt;a href="https://sbomify.com/compliance/eu-cra/">EU Cyber Resilience Act&lt;/a> (CRA) requires manufacturers of products with digital elements to identify and document vulnerabilities and components, including providing SBOMs. The CRA makes software supply chain transparency a legal obligation for products sold in the EU market.&lt;/p>
&lt;h3 id="slsa-framework">SLSA Framework&lt;/h3>
&lt;p>&lt;a href="https://slsa.dev/">SLSA&lt;/a> (Supply-chain Levels for Software Artifacts) is a framework from the &lt;a href="https://openssf.org/">OpenSSF&lt;/a> that defines three levels of build security maturity in the current &lt;a href="https://slsa.dev/spec/v1.0/levels">v1.0 specification&lt;/a>. Each level adds protections: from documenting build provenance (Level 1) through using a hosted build platform (Level 2) to hardened, tamper-resistant builds (Level 3).&lt;/p>
&lt;h2 id="how-sboms-support-supply-chain-management">How SBOMs Support Supply Chain Management&lt;/h2>
&lt;p>An &lt;a href="https://sbomify.com/what-is-sbom/">SBOM&lt;/a> is the foundational tool for software supply chain visibility. Without knowing what components are in your software, you cannot assess supply chain risk. SBOMs support supply chain management in several ways:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Component visibility.&lt;/strong> SBOMs provide a complete inventory of every library, framework, and module in your application, including transitive dependencies that developers may not be aware of.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Vulnerability identification.&lt;/strong> Once you have an SBOM, platforms like &lt;a href="https://sbomify.com">sbomify&lt;/a> and &lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a> can continuously match your components against vulnerability databases like the &lt;a href="https://nvd.nist.gov/">NVD&lt;/a> and &lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA KEV catalog&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>License compliance.&lt;/strong> SBOMs document the license of each component, enabling automated detection of copyleft or restrictive licenses that may create legal obligations. See our &lt;a href="https://sbomify.com/2025/12/22/gpl-license-guide/">GPL license guide&lt;/a> for details on copyleft compliance.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Incident response.&lt;/strong> When a new vulnerability is disclosed, SBOMs allow you to immediately determine which of your products are affected, drastically reducing response time.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Regulatory compliance.&lt;/strong> Multiple frameworks now require or strongly recommend SBOMs, including &lt;a href="https://sbomify.com/compliance/eo-14028/">EO 14028&lt;/a>, the &lt;a href="https://sbomify.com/compliance/eu-cra/">EU CRA&lt;/a>, and &lt;a href="https://sbomify.com/compliance/fda-medical-device/">FDA medical device guidance&lt;/a>. See our &lt;a href="https://sbomify.com/compliance/">compliance guide&lt;/a> for a complete comparison.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>To start generating SBOMs for your projects, see our &lt;a href="https://sbomify.com/guides/">language-specific SBOM guides&lt;/a> covering Python, JavaScript, Java, Go, Rust, and more.&lt;/p>
&lt;h2 id="best-practices-for-software-supply-chain-security">Best Practices for Software Supply Chain Security&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Generate and maintain SBOMs.&lt;/strong> Automate SBOM generation in your CI/CD pipeline using tools like the &lt;a href="https://github.com/sbomify/github-action/">sbomify GitHub Action&lt;/a>. Keep SBOMs current with every release.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Monitor dependencies continuously.&lt;/strong> Do not rely on point-in-time audits. Use SBOM-based monitoring to catch newly disclosed vulnerabilities in your deployed components.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Verify component provenance.&lt;/strong> Use signed packages, verify checksums, and adopt frameworks like SLSA to ensure components have not been tampered with between source and deployment.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Minimize your dependency footprint.&lt;/strong> Fewer dependencies mean a smaller attack surface. Regularly review and remove unused dependencies. Prefer well-maintained libraries with active security response processes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Pin and lock dependencies.&lt;/strong> Use lock files to ensure reproducible builds and prevent unexpected dependency updates. Review dependency changes before merging.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Establish a vulnerability response process.&lt;/strong> Define SLAs for patching based on severity and exploitability. Monitor the &lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA KEV catalog&lt;/a> for actively exploited vulnerabilities in your stack.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Evaluate suppliers.&lt;/strong> For critical commercial dependencies, assess the vendor&amp;rsquo;s security practices, including whether they provide SBOMs and maintain vulnerability disclosure processes.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="frequently-asked-questions">Frequently Asked Questions&lt;/h2>
&lt;h3 id="what-is-software-supply-chain-management">What is software supply chain management?&lt;/h3>
&lt;p>Software supply chain management is the practice of identifying, assessing, and mitigating risks across the full chain of components, tools, and processes used to build and deliver software. It encompasses open source dependency management, build pipeline security, vendor assessment, and ongoing vulnerability monitoring. The goal is to ensure that every component in your software is known, trusted, and up to date.&lt;/p>
&lt;h3 id="what-is-a-chain-of-custody-in-software">What is a chain of custody in software?&lt;/h3>
&lt;p>Chain of custody in the software context refers to the documented, verifiable record of who created, modified, built, and distributed each component in a software product. It establishes trust by providing evidence that a component has not been tampered with between its source and its deployment. SBOMs, build attestations (like SLSA provenance), and code signing are the primary tools for establishing software chain of custody.&lt;/p>
&lt;h3 id="how-do-sboms-help-with-supply-chain-security">How do SBOMs help with supply chain security?&lt;/h3>
&lt;p>SBOMs provide the component-level visibility that is the foundation of supply chain security. Without knowing what is in your software, you cannot assess risk, identify vulnerabilities, or respond to incidents. SBOMs enable automated vulnerability scanning, license compliance checking, and rapid incident response when new vulnerabilities like Log4Shell are disclosed. They are required or recommended by most major compliance frameworks.&lt;/p>
&lt;h3 id="what-is-the-nist-risk-management-framework-for-supply-chains">What is the NIST risk management framework for supply chains?&lt;/h3>
&lt;p>NIST publishes several frameworks relevant to supply chain risk management. &lt;a href="https://csrc.nist.gov/pubs/sp/800/161/r1/final">NIST SP 800-161 Rev 1&lt;/a> is the primary guidance for cybersecurity supply chain risk management (C-SCRM). &lt;a href="https://sbomify.com/compliance/nist-800-53/">NIST SP 800-53 Rev 5&lt;/a> includes the SR (Supply Chain Risk Management) control family with specific controls for provenance (SR-4) and supply chain processes (SR-3). These frameworks are increasingly referenced in procurement requirements and compliance obligations.&lt;/p>
&lt;h3 id="what-are-the-biggest-software-supply-chain-risks">What are the biggest software supply chain risks?&lt;/h3>
&lt;p>The most significant risks include: vulnerable open source dependencies (the most common attack surface), compromised build systems (as in SolarWinds), malicious packages in public registries (typosquatting and dependency confusion), and social engineering of open source maintainers (as in XZ Utils). Transitive dependencies, which are pulled in indirectly and often unreviewed, represent a particularly underestimated risk.&lt;/p></description><category>education</category></item><item><title>Securing the Software Supply Chain with SLSA: What You Need to Know</title><link>https://sbomify.com/2024/08/17/what-is-slsa/</link><pubDate>Sat, 17 Aug 2024 00:00:00 +0000</pubDate><guid>https://sbomify.com/2024/08/17/what-is-slsa/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>In a world where software is integral to almost every aspect of life, securing the software supply chain is more critical than ever. The increasing complexity of software systems has given rise to sophisticated cyberattacks, particularly those targeting the software supply chain. To combat these threats, Google introduced &lt;strong>SLSA (Supply chain Levels for Software Artifacts)&lt;/strong>—a framework that provides a structured approach to safeguarding software development and ensuring that software artifacts are secure and tamper-free throughout their lifecycle. Pronounced &amp;ldquo;salsa,&amp;rdquo; SLSA is essential for defending against supply chain attacks, maintaining software integrity, providing transparency, encouraging best practices, and meeting compliance standards. Additionally, GitHub now supports artifact attestations, further enhancing the ability to establish and verify provenance within the SLSA framework.&lt;/p>
&lt;h2 id="what-is-slsa">What is SLSA?&lt;/h2>
&lt;p>SLSA, which stands for Supply chain Levels for Software Artifacts, is a security framework designed to protect the integrity of software artifacts from the earliest stages of development through to deployment. Introduced by Google, SLSA offers a standardized approach to securing the software supply chain, addressing vulnerabilities that could otherwise be exploited by cybercriminals.&lt;/p>
&lt;p>The framework is structured into four levels, each corresponding to a progressively higher degree of security maturity:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>SLSA Level 1: Basic Build Integrity&lt;/strong>
At this foundational level, organizations implement basic security practices, such as using version control systems (VCS) and documenting their build processes. This establishes a baseline for more advanced security measures.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>SLSA Level 2: Higher Build Integrity&lt;/strong>
Building on Level 1, this stage introduces stronger controls like using a dedicated build service to prevent unauthorized changes. The goal is to enhance the integrity of the software as it progresses through the development pipeline.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>SLSA Level 3: Provenance&lt;/strong>
Provenance is a key feature at this level, offering traceability and transparency regarding the origin of software artifacts. This level ensures that organizations can verify the entire history of their software, including who built it and how it was built. GitHub, one of the most widely used platforms for software development, now supports artifact attestations, enabling developers to create and verify attestations for software artifacts built using GitHub Actions. This capability allows organizations to seamlessly integrate provenance tracking into their development workflows, aligning with SLSA Level 3 requirements.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>SLSA Level 4: Hermetic Builds and Two-Person Review&lt;/strong>
The highest level of SLSA emphasizes maximum security with hermetic builds—completely isolated build environments—and a mandatory two-person review process. These practices help detect any issues before software deployment, ensuring the highest level of security.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="why-slsa-matters">Why SLSA Matters&lt;/h2>
&lt;p>The importance of SLSA in today’s digital landscape cannot be overstated. As cyber threats continue to evolve, securing the software supply chain has become essential to preventing widespread damage and maintaining trust in digital systems. Here’s why SLSA is crucial:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Defending Against Supply Chain Attacks&lt;/strong>
Supply chain attacks are a growing concern, with attackers targeting the software development process to introduce malicious code. SLSA helps organizations defend against these threats by implementing robust security measures at every stage of software development.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Ensuring Software Integrity and Trust&lt;/strong>
SLSA ensures that software remains untampered throughout its lifecycle, which is critical for maintaining trust, especially in industries where security is paramount, such as healthcare, finance, and government.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Providing Transparency with Provenance&lt;/strong>
The concept of provenance, introduced at SLSA Level 3, offers a clear record of the software’s origin and development history. With GitHub&amp;rsquo;s support for artifact attestations, organizations can now generate and verify these attestations directly within their development workflows, ensuring that the software’s authenticity and history are transparent and verifiable.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Encouraging Adoption of Best Practices&lt;/strong>
By following the SLSA framework, organizations naturally adopt industry best practices for software security. This strengthens their own systems and contributes to the overall security of the software ecosystem.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Achieving Compliance and Regulatory Standards&lt;/strong>
With cybersecurity regulations becoming more stringent, adhering to SLSA can help organizations meet compliance requirements, avoiding legal consequences and demonstrating a commitment to security that can serve as a competitive advantage.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>By adopting SLSA and leveraging tools like GitHub&amp;rsquo;s artifact attestations, organizations can protect their software from threats, ensure its integrity, and contribute to a safer digital environment for all.&lt;/p></description><category>education</category></item><item><title>Understanding in-toto: Securing the Software Supply Chain</title><link>https://sbomify.com/2024/08/14/what-is-in-toto/</link><pubDate>Wed, 14 Aug 2024 00:00:00 +0000</pubDate><guid>https://sbomify.com/2024/08/14/what-is-in-toto/</guid><description>&lt;p>In today&amp;rsquo;s software landscape, securing the software supply chain is more crucial than ever. With increasing concerns about vulnerabilities and supply chain attacks, developers and organizations are looking for robust solutions to ensure the integrity of their software from development to deployment. One such solution is &lt;strong>&lt;a href="https://github.com/in-toto/in-toto">in-toto&lt;/a>&lt;/strong>. In this post, we&amp;rsquo;ll explore what in-toto is, how it works, and why it might be the key to securing your software supply chain.&lt;/p>
&lt;h3 id="what-is-in-toto">What is in-toto?&lt;/h3>
&lt;p>In-toto is an open-source framework designed to secure the entire software supply chain. It provides a way to ensure that all steps in the software development and deployment process are executed as intended, without tampering or unintended changes. The name &amp;ldquo;in-toto&amp;rdquo; is derived from the Latin phrase &amp;ldquo;in toto,&amp;rdquo; meaning &amp;ldquo;in total&amp;rdquo; or &amp;ldquo;completely,&amp;rdquo; which reflects the framework&amp;rsquo;s comprehensive approach to security.&lt;/p>
&lt;p>The in-toto framework was originally developed by researchers at New York University as part of the Supply Chain Integrity, Transparency, and Trust (SCITT) project. It is now maintained as an open-source project and has been adopted by various organizations to enhance the security of their development pipelines.&lt;/p>
&lt;h3 id="how-does-in-toto-work">How Does in-toto Work?&lt;/h3>
&lt;p>In-toto operates by establishing a chain of trust throughout the entire software supply chain. It does this through a series of steps:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Defining a Layout&lt;/strong>: The first step in using in-toto is to define a &amp;ldquo;layout,&amp;rdquo; which is essentially a blueprint of the software supply chain. The layout specifies the steps involved in the development process, the expected materials and products of each step, and the parties responsible for executing those steps.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Creating and Signing Link Metadata&lt;/strong>: As each step in the layout is executed, in-toto generates &amp;ldquo;link metadata,&amp;rdquo; which records the details of the step, including the command run, the materials used (such as source code), and the products generated (such as binaries). This metadata is then signed by the entity responsible for the step, creating a cryptographic proof of its execution.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Verifying the Supply Chain&lt;/strong>: Once all steps are completed, in-toto verifies the entire supply chain by checking that each step was executed according to the layout and that the link metadata is valid. This ensures that no unauthorized changes were made during the process.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Reproducibility and Transparency&lt;/strong>: In-toto emphasizes transparency by making all the metadata and verification processes open and auditable. This allows for third-party verification and ensures that the integrity of the software can be independently verified.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="why-is-in-toto-important">Why is in-toto Important?&lt;/h3>
&lt;p>In-toto addresses several key challenges in securing the software supply chain:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Preventing Supply Chain Attacks&lt;/strong>: By providing end-to-end verification of the software supply chain, in-toto helps prevent attacks where malicious actors might attempt to inject vulnerabilities during the development process.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Ensuring Compliance&lt;/strong>: For organizations that need to comply with regulatory requirements or internal security policies, in-toto provides a clear and auditable trail of the software&amp;rsquo;s development history.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Building Trust&lt;/strong>: In-toto&amp;rsquo;s transparent and verifiable process builds trust among developers, users, and stakeholders, ensuring that the software they rely on has not been tampered with.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="real-world-use-cases">Real-World Use Cases&lt;/h3>
&lt;p>In-toto has been adopted by several organizations and integrated into popular tools and frameworks:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>The Open Source Security Foundation (OpenSSF)&lt;/strong>: In-toto is part of the OpenSSF&amp;rsquo;s efforts to secure open-source software, providing a framework to protect against supply chain attacks in critical open-source projects.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Tern&lt;/strong>: Tern, a tool for container image inspection, uses in-toto to track and verify the steps involved in building a container image, ensuring its integrity.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Datadog&lt;/strong>: Datadog, a cloud monitoring platform, has integrated in-toto into its CI/CD pipeline to secure the delivery of its software updates.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="getting-started-with-in-toto">Getting Started with in-toto&lt;/h3>
&lt;p>To start using in-toto, you can visit the &lt;a href="https://github.com/in-toto/in-toto">in-toto GitHub repository&lt;/a> for detailed documentation and examples. The repository provides guides on how to define layouts, generate link metadata, and verify the software supply chain.&lt;/p>
&lt;p>In-toto is implemented in Python, and you can install it via pip:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install in-toto
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>From there, you can start defining your software supply chain&amp;rsquo;s layout and securing your development pipeline.&lt;/p>
&lt;h3 id="wrapping-up">Wrapping up&lt;/h3>
&lt;p>In-toto offers a powerful and flexible framework for securing the software supply chain, addressing the growing concerns of supply chain attacks and software integrity. By incorporating in-toto into your development processes, you can ensure that your software is built and delivered exactly as intended, without any unauthorized changes. As supply chain security becomes increasingly important, tools like in-toto are invaluable in safeguarding the integrity of your software.&lt;/p>
&lt;p>Stay secure, and happy coding!&lt;/p></description><category>education</category></item><item><title>Framing Software Component Transparency: Establishing a Common Software Bill of Materials (SBOM)</title><link>https://sbomify.com/2024/06/11/framing-software-component-transparency-establishing-a-common-software-bill-of-materials-sbom/</link><pubDate>Tue, 11 Jun 2024 08:03:32 +0200</pubDate><guid>https://sbomify.com/2024/06/11/framing-software-component-transparency-establishing-a-common-software-bill-of-materials-sbom/</guid><description>&lt;p>As the digital world grows ever more complex, the tools we use to ensure software security and transparency must evolve. The 2nd edition of &lt;a href="https://www.ntia.gov/files/ntia/publications/ntia_sbom_framing_2nd_edition_20211021.pdf">Framing Software Component Transparency: Establishing a Common Software Bill of Materials (SBOM)&lt;/a> has been pivotal in laying down the standards necessary for identifying and managing software components. This edition emphasized transparency, interoperability, and security, enabling organizations to manage vulnerabilities more effectively and enhance trust across software supply chains.&lt;/p>
&lt;h4 id="key-highlights-from-the-2nd-edition">Key Highlights from the 2nd Edition&lt;/h4>
&lt;ol>
&lt;li>&lt;strong>Enhanced Transparency&lt;/strong>: Improved clarity and accessibility of software component information, critical for managing vulnerabilities and ensuring system integrity.&lt;/li>
&lt;li>&lt;strong>Interoperability Standards&lt;/strong>: Establishing a common framework that facilitates better communication and compatibility across different systems and organizations.&lt;/li>
&lt;li>&lt;strong>Security and Risk Management&lt;/strong>: Providing detailed insights into software components, empowering organizations to manage risks proactively.&lt;/li>
&lt;li>&lt;strong>Community and Collaboration&lt;/strong>: Encouraging a collaborative environment among developers, suppliers, and users to maintain software reliability.&lt;/li>
&lt;/ol>
&lt;h4 id="looking-ahead-to-the-3rd-edition">Looking Ahead to the 3rd Edition&lt;/h4>
&lt;p>The forthcoming 3rd edition of &lt;em>Framing Software Component Transparency: Establishing a Common Software Bill of Materials (SBOM)&lt;/em> is set to build on the robust foundation laid by its predecessor. Here’s what we can anticipate:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Advanced Security Measures&lt;/strong>: Introducing more robust protocols to counter sophisticated cyber threats.&lt;/li>
&lt;li>&lt;strong>Greater Automation&lt;/strong>: Incorporating advanced automation tools to streamline SBOM creation and management, reducing manual efforts and errors.&lt;/li>
&lt;li>&lt;strong>Expanded Scope&lt;/strong>: Covering a broader range of software types and use cases to reflect the dynamic nature of modern technology.&lt;/li>
&lt;li>&lt;strong>Global Standards Alignment&lt;/strong>: Ensuring SBOM practices align with international standards to promote global interoperability and security.&lt;/li>
&lt;/ul>
&lt;h4 id="notable-additions-in-the-3rd-edition-draft">Notable Additions in the 3rd Edition Draft&lt;/h4>
&lt;ol>
&lt;li>&lt;strong>Updated Language and Clarifications&lt;/strong>: To enhance understanding and implementation of SBOM attributes.&lt;/li>
&lt;li>&lt;strong>New Baseline Attributes&lt;/strong>: Inclusion of license and copyright holder information.&lt;/li>
&lt;li>&lt;strong>Data Maturity Levels&lt;/strong>: Introducing minimum expected, recommended practice, and aspirational goal maturity levels for SBOM attributes.&lt;/li>
&lt;li>&lt;strong>Handling Undeclared Data&lt;/strong>: Providing guidelines for managing unknown or redacted components and dependencies.&lt;/li>
&lt;/ol>
&lt;p>As we eagerly await the release of the 3rd edition, it&amp;rsquo;s crucial to reflect on the progress made and prepare for the future advancements in software security and transparency that the new edition promises. The continuous evolution of the SBOM framework is a testament to the collaborative efforts of the software community, aiming to create a more secure and transparent digital ecosystem.&lt;/p>
&lt;p>Stay tuned for more updates and insights as the 3rd edition of the SBOM Framing becomes available, setting the stage for the next chapter in software security and management.&lt;/p></description><category>education</category></item><item><title>What really happened to XZ?</title><link>https://sbomify.com/2024/04/13/what-really-happened-to-xz/</link><pubDate>Sat, 13 Apr 2024 11:49:21 +0200</pubDate><guid>https://sbomify.com/2024/04/13/what-really-happened-to-xz/</guid><description>&lt;p>The article &amp;ldquo;XZ Backdoor Story Part 1&amp;rdquo; from Securelist delves into the discovery and analysis of a backdoor found in XZ, which is commonly used in various Linux distributions and OpenSSH server processes. This piece provides an initial technical overview of how the backdoor operates, its implications for security, and the broader context of its use in cyber-attacks.&lt;/p>
&lt;p>Kaspersky&amp;rsquo;s researchers detail the technical characteristics of the backdoor, discussing its potential origins and the techniques it employs to compromise systems. They also explore the broader trend of increasing sophistication in malware design and the ongoing challenges of securing open-source software components from such stealthy infiltrations.&lt;/p>
&lt;p>The discussion also touches on the importance of robust cybersecurity measures and the need for continuous monitoring and updating of systems to defend against these evolving threats. The analysis serves as a cautionary tale about the vulnerabilities that can be exploited in widely used software and the necessity for the cybersecurity community to remain vigilant against such hidden threats.&lt;/p>
&lt;p>For further details on this analysis, you can read the full article on &lt;a href="https://securelist.com/xz-backdoor-story-part-1/112354/">Securelist&amp;rsquo;s website&lt;/a>.&lt;/p></description><category>news</category></item><item><title>A Paradigm Shift for Software Vendors in SBOM Management</title><link>https://sbomify.com/2024/04/03/sbomify-a-paradigm-shift-for-software-vendors-in-sbom-management/</link><pubDate>Wed, 03 Apr 2024 13:54:17 +0200</pubDate><guid>https://sbomify.com/2024/04/03/sbomify-a-paradigm-shift-for-software-vendors-in-sbom-management/</guid><description>&lt;p>For software vendors, managing Software Bill of Materials (SBOMs) is an integral part of the development process, ensuring that their products are secure, compliant, and ready for the market. However, this often involves a complex and time-consuming process, especially for applications with intricate stacks. sbomify introduces a paradigm shift in SBOM management, offering a seamless solution that integrates directly into the existing CI/CD pipeline, simplifying and enhancing the way vendors manage their SBOMs.&lt;/p>
&lt;h3 id="seamless-integration-and-easy-management">Seamless Integration and Easy Management&lt;/h3>
&lt;p>sbomify&amp;rsquo;s platform is designed to fit effortlessly into the software development lifecycle, allowing vendors to integrate SBOM management into their CI/CD pipeline. This integration simplifies the management of even the most complex application stacks, making it easier for vendors to keep track of all components and their respective vulnerabilities.&lt;/p>
&lt;h3 id="focus-on-innovation">Focus on Innovation&lt;/h3>
&lt;p>By reducing the administrative overhead associated with SBOM management, sbomify enables software vendors to focus on what they do best: innovation. The platform&amp;rsquo;s intuitive interface and automated processes ensure that vendors can manage their SBOMs efficiently, without detracting from the essential task of developing high-quality software.&lt;/p>
&lt;h3 id="enhanced-security-and-compliance">Enhanced Security and Compliance&lt;/h3>
&lt;p>With sbomify, vendors have a comprehensive overview of their software components, including detailed information on vulnerabilities and software licenses. This not only helps in identifying and addressing potential security issues early in the development process but also ensures that all software components are compliant with relevant licenses and regulations.&lt;/p>
&lt;p>For software vendors, sbomify represents a significant leap forward in SBOM management. By streamlining the process and integrating it into the development workflow, sbomify ensures that vendors can manage their SBOMs more effectively, leading to better software products and a more secure software ecosystem.&lt;/p></description><category>education</category></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sbomify</title><link>https://sbomify.com/tags/security/</link><description>Your Security Artifact Hub. From zero to SBOM hero. Generate, manage, and share SBOMs and compliance documents. Built for CRA compliance and seamless integration with your existing tools.</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 05 Feb 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://sbomify.com/tags/security/" rel="self" type="application/rss+xml"/><item><title>What Is CVSS? Understanding Vulnerability Severity Scoring</title><link>https://sbomify.com/2026/02/05/what-is-cvss-vulnerability-scoring/</link><pubDate>Thu, 05 Feb 2026 00:00:00 +0000</pubDate><guid>https://sbomify.com/2026/02/05/what-is-cvss-vulnerability-scoring/</guid><description>&lt;p>The Common Vulnerability Scoring System (CVSS) is an open framework for communicating the severity of software vulnerabilities. Published and maintained by &lt;a href="https://www.first.org/cvss/">FIRST.org&lt;/a> (the Forum of Incident Response and Security Teams), CVSS produces a numerical score from 0.0 to 10.0 that represents the severity of a vulnerability. The score is accompanied by a vector string that describes the specific characteristics used to calculate it. CVSS is the most widely used vulnerability scoring system in the world — the &lt;a href="https://nvd.nist.gov/">National Vulnerability Database&lt;/a> (NVD) publishes CVSS scores for virtually every &lt;a href="https://sbomify.com/2025/12/18/cve-vulnerability-explained/">CVE&lt;/a> entry.&lt;/p>
&lt;h2 id="how-cvss-scores-work">How CVSS Scores Work&lt;/h2>
&lt;p>A CVSS score is not a single number derived from one input. It is calculated from a set of metrics organized into metric groups. Each metric describes a specific characteristic of the vulnerability, and the combination produces the final score.&lt;/p>
&lt;h3 id="cvss-v31-metric-groups">CVSS v3.1 Metric Groups&lt;/h3>
&lt;p>CVSS v3.1 (the most widely deployed version as of early 2026) defines three metric groups:&lt;/p>
&lt;p>&lt;strong>Base Score (0.0-10.0)&lt;/strong> — Represents the intrinsic qualities of the vulnerability that are constant over time and across environments. This is the score most commonly reported.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Attack Vector (AV):&lt;/strong> How the vulnerability is exploited — Network (remote), Adjacent (local network), Local (requires local access), or Physical (requires physical access)&lt;/li>
&lt;li>&lt;strong>Attack Complexity (AC):&lt;/strong> Whether specialized conditions must exist for exploitation — Low or High&lt;/li>
&lt;li>&lt;strong>Privileges Required (PR):&lt;/strong> What level of privilege an attacker needs — None, Low, or High&lt;/li>
&lt;li>&lt;strong>User Interaction (UI):&lt;/strong> Whether a user must take action for exploitation — None or Required&lt;/li>
&lt;li>&lt;strong>Scope (S):&lt;/strong> Whether exploitation impacts resources beyond the vulnerable component — Unchanged or Changed&lt;/li>
&lt;li>&lt;strong>Confidentiality Impact (C):&lt;/strong> Impact on data confidentiality — None, Low, or High&lt;/li>
&lt;li>&lt;strong>Integrity Impact (I):&lt;/strong> Impact on data integrity — None, Low, or High&lt;/li>
&lt;li>&lt;strong>Availability Impact (A):&lt;/strong> Impact on system availability — None, Low, or High&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Temporal Score&lt;/strong> — Adjusts the Base Score based on factors that change over time, such as whether an exploit is available, whether a patch exists, and confidence in the vulnerability report.&lt;/p>
&lt;p>&lt;strong>Environmental Score&lt;/strong> — Adjusts the score based on the specific environment where the vulnerability exists, allowing organizations to reflect their own infrastructure context.&lt;/p>
&lt;h3 id="severity-ratings">Severity Ratings&lt;/h3>
&lt;p>CVSS scores map to qualitative severity ratings:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Score Range&lt;/th>
&lt;th>Severity&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0.0&lt;/td>
&lt;td>None&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0.1 - 3.9&lt;/td>
&lt;td>Low&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4.0 - 6.9&lt;/td>
&lt;td>Medium&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7.0 - 8.9&lt;/td>
&lt;td>High&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9.0 - 10.0&lt;/td>
&lt;td>Critical&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="reading-a-cvss-vector-string">Reading a CVSS Vector String&lt;/h3>
&lt;p>The CVSS vector string encodes all the metric values in a compact format. For example:&lt;/p>
&lt;p>&lt;code>CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H&lt;/code> — Score: 10.0 (Critical)&lt;/p>
&lt;p>This describes &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-44228">Log4Shell (CVE-2021-44228)&lt;/a>: exploitable over the network (AV:N), with low attack complexity (AC:L), requiring no privileges (PR:N) and no user interaction (UI:N), with changed scope (S:C), and high impact on confidentiality, integrity, and availability.&lt;/p>
&lt;p>Compare with: &lt;code>CVSS:3.1/AV:L/AC:H/PR:H/UI:R/S:U/C:L/I:N/A:N&lt;/code> — Score: 1.8 (Low)&lt;/p>
&lt;p>This describes a vulnerability requiring local access, high complexity, high privileges, user interaction, and producing only low confidentiality impact — a much less severe threat.&lt;/p>
&lt;h2 id="cvss-v40">CVSS v4.0&lt;/h2>
&lt;p>&lt;a href="https://www.first.org/cvss/v4-0/">CVSS v4.0&lt;/a> was released by FIRST.org in November 2023 and represents a significant evolution of the framework. While CVSS v3.1 remains the most widely used version (the NVD still primarily publishes v3.1 scores), v4.0 adoption is increasing.&lt;/p>
&lt;h3 id="key-changes-in-v40">Key Changes in v4.0&lt;/h3>
&lt;p>&lt;strong>New metric groups.&lt;/strong> CVSS v4.0 restructures the scoring into four metric groups:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Base&lt;/strong> — Intrinsic vulnerability characteristics (similar to v3.1)&lt;/li>
&lt;li>&lt;strong>Threat&lt;/strong> — Replaces the Temporal group; focused on exploit maturity&lt;/li>
&lt;li>&lt;strong>Environmental&lt;/strong> — Organization-specific adjustments&lt;/li>
&lt;li>&lt;strong>Supplemental&lt;/strong> — Additional context that does not affect the score (e.g., safety impact, automatable, recovery)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Removed Scope metric.&lt;/strong> The Scope (S) metric from v3.1, which was widely considered confusing and inconsistently applied, has been removed. Its effects are captured through refined impact metrics.&lt;/p>
&lt;p>&lt;strong>Attack Requirements.&lt;/strong> A new metric (AT) distinguishes between vulnerabilities that require specific deployment conditions and those that do not, providing more nuance than v3.1&amp;rsquo;s Attack Complexity.&lt;/p>
&lt;p>&lt;strong>Multiple score types.&lt;/strong> CVSS v4.0 defines specific score types:&lt;/p>
&lt;ul>
&lt;li>CVSS-B: Base score only&lt;/li>
&lt;li>CVSS-BT: Base + Threat&lt;/li>
&lt;li>CVSS-BE: Base + Environmental&lt;/li>
&lt;li>CVSS-BTE: Base + Threat + Environmental (most complete)&lt;/li>
&lt;/ul>
&lt;h3 id="v31-vs-v40">v3.1 vs. v4.0&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Aspect&lt;/th>
&lt;th>CVSS v3.1&lt;/th>
&lt;th>CVSS v4.0&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Metric groups&lt;/strong>&lt;/td>
&lt;td>Base, Temporal, Environmental&lt;/td>
&lt;td>Base, Threat, Environmental, Supplemental&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Scope metric&lt;/strong>&lt;/td>
&lt;td>Present (Unchanged/Changed)&lt;/td>
&lt;td>Removed&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Attack granularity&lt;/strong>&lt;/td>
&lt;td>Attack Complexity (Low/High)&lt;/td>
&lt;td>Attack Complexity + Attack Requirements&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Score types&lt;/strong>&lt;/td>
&lt;td>One composite score&lt;/td>
&lt;td>Four named score types (B, BT, BE, BTE)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>NVD support&lt;/strong>&lt;/td>
&lt;td>Fully supported&lt;/td>
&lt;td>Adoption in progress&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Adoption status&lt;/strong>&lt;/td>
&lt;td>Industry standard&lt;/td>
&lt;td>Growing adoption&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Both versions produce scores on the same 0.0-10.0 scale with the same severity ratings. A score of 9.8 means roughly the same severity in both versions, though the exact metrics contributing to that score may differ.&lt;/p>
&lt;h2 id="cvss-in-vulnerability-prioritization">CVSS in Vulnerability Prioritization&lt;/h2>
&lt;p>CVSS scores are essential for vulnerability prioritization, but they should not be the only signal.&lt;/p>
&lt;h3 id="cvss-alone-is-not-enough">CVSS Alone Is Not Enough&lt;/h3>
&lt;p>A CVSS Base Score measures theoretical severity — how bad the vulnerability &lt;em>could&lt;/em> be if exploited. It does not tell you:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Whether it is being exploited.&lt;/strong> The &lt;a href="https://sbomify.com/2025/12/30/what-is-kev-cisa-known-exploited-vulnerabilities/">CISA KEV catalog&lt;/a> answers this question. A CVSS 7.5 vulnerability that is actively exploited (KEV-listed) is more urgent than a CVSS 9.8 vulnerability with no known exploits.&lt;/li>
&lt;li>&lt;strong>Whether you are affected.&lt;/strong> A critical vulnerability in a component you do not use, or in a code path your application never reaches, represents zero actual risk to you.&lt;/li>
&lt;li>&lt;strong>Your deployment context.&lt;/strong> A network-exploitable vulnerability in an internet-facing application is far more urgent than the same vulnerability in a completely internal tool.&lt;/li>
&lt;/ul>
&lt;h3 id="a-combined-prioritization-approach">A Combined Prioritization Approach&lt;/h3>
&lt;p>Effective vulnerability prioritization uses CVSS together with other signals:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Signal&lt;/th>
&lt;th>Source&lt;/th>
&lt;th>What It Tells You&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>CVSS&lt;/strong>&lt;/td>
&lt;td>NVD, vendor advisories&lt;/td>
&lt;td>Theoretical severity (how bad it could be)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>KEV&lt;/strong>&lt;/td>
&lt;td>&lt;a href="https://sbomify.com/2025/12/30/what-is-kev-cisa-known-exploited-vulnerabilities/">CISA KEV catalog&lt;/a>&lt;/td>
&lt;td>Whether it is actively exploited&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>EPSS&lt;/strong>&lt;/td>
&lt;td>&lt;a href="https://www.first.org/epss/">FIRST.org EPSS&lt;/a>&lt;/td>
&lt;td>Probability of exploitation in the next 30 days&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>SBOM&lt;/strong>&lt;/td>
&lt;td>Your component inventory&lt;/td>
&lt;td>Whether you use the affected component&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Context&lt;/strong>&lt;/td>
&lt;td>Your deployment architecture&lt;/td>
&lt;td>Whether the vulnerability is reachable&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>For a practical prioritization framework that combines CVSS with KEV status and deployment context, see our &lt;a href="https://sbomify.com/2025/12/30/what-is-kev-cisa-known-exploited-vulnerabilities/">KEV guide&lt;/a>.&lt;/p>
&lt;h2 id="cvss-and-sboms">CVSS and SBOMs&lt;/h2>
&lt;p>&lt;a href="https://sbomify.com/what-is-sbom/">SBOMs&lt;/a> enable CVSS-based vulnerability management at scale. Without an SBOM, you need to manually determine which components are in your software before you can look up their CVSS scores. With an SBOM, this process is automated.&lt;/p>
&lt;h3 id="the-workflow">The Workflow&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>Generate SBOMs&lt;/strong> for your applications using tools from our &lt;a href="https://sbomify.com/guides/">SBOM generation guides&lt;/a>&lt;/li>
&lt;li>&lt;strong>Ingest SBOMs&lt;/strong> into a monitoring platform like &lt;a href="https://sbomify.com">sbomify&lt;/a> or &lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a>&lt;/li>
&lt;li>&lt;strong>Automatic matching&lt;/strong> — the platform matches your components against vulnerability databases and retrieves CVSS scores&lt;/li>
&lt;li>&lt;strong>Prioritize&lt;/strong> using CVSS severity combined with KEV status and your deployment context&lt;/li>
&lt;li>&lt;strong>Remediate&lt;/strong> according to your defined SLAs&lt;/li>
&lt;/ol>
&lt;h3 id="cvss-in-sbom-formats">CVSS in SBOM Formats&lt;/h3>
&lt;p>&lt;a href="https://cyclonedx.org/">CycloneDX&lt;/a> includes a &lt;code>vulnerabilities&lt;/code> array that can carry CVSS scores directly within the SBOM or an associated VEX document. This allows a single document to contain both the component inventory and its known vulnerabilities with scores.&lt;/p>
&lt;p>&lt;a href="https://spdx.dev/">SPDX 3.0&lt;/a> supports vulnerability information through its Security profile, which can reference CVSS data.&lt;/p>
&lt;p>For more on SBOM scanning and vulnerability detection, see our &lt;a href="https://sbomify.com/2026/02/01/sbom-scanning-vulnerability-detection/">SBOM scanning guide&lt;/a>.&lt;/p>
&lt;h2 id="frequently-asked-questions">Frequently Asked Questions&lt;/h2>
&lt;h3 id="what-is-cvss">What is CVSS?&lt;/h3>
&lt;p>The Common Vulnerability Scoring System (CVSS) is an open framework maintained by FIRST.org for scoring the severity of software vulnerabilities on a scale of 0.0 to 10.0. Scores are calculated from metrics describing the vulnerability&amp;rsquo;s attack vector, complexity, required privileges, and potential impact. CVSS scores are published by the NVD for virtually every CVE and are the most widely used measure of vulnerability severity.&lt;/p>
&lt;h3 id="what-is-a-good-cvss-score">What is a good CVSS score?&lt;/h3>
&lt;p>Lower CVSS scores indicate less severe vulnerabilities. A score of 0.0 means no impact. Scores of 0.1-3.9 are Low severity, 4.0-6.9 are Medium, 7.0-8.9 are High, and 9.0-10.0 are Critical. However, &amp;ldquo;good&amp;rdquo; depends on context — even a Medium vulnerability is urgent if it is being actively exploited (listed in the CISA KEV catalog) or in an internet-facing system.&lt;/p>
&lt;h3 id="what-is-the-difference-between-cvss-v31-and-v40">What is the difference between CVSS v3.1 and v4.0?&lt;/h3>
&lt;p>CVSS v4.0 introduces refined metric groups (Base, Threat, Environmental, Supplemental), removes the controversial Scope metric, adds an Attack Requirements metric for more granular exploitability assessment, and defines four named score types (CVSS-B, CVSS-BT, CVSS-BE, CVSS-BTE). Both versions use the same 0.0-10.0 scale and severity ratings. CVSS v3.1 remains more widely deployed; v4.0 adoption is growing.&lt;/p>
&lt;h3 id="how-should-i-prioritize-vulnerabilities">How should I prioritize vulnerabilities?&lt;/h3>
&lt;p>Do not rely on CVSS scores alone. Combine CVSS severity with CISA KEV status (is it actively exploited?), EPSS probability (how likely is exploitation?), your SBOM (do you use the affected component?), and deployment context (is the vulnerable component exposed?). A KEV-listed vulnerability at CVSS 7.5 often warrants faster action than a non-exploited vulnerability at CVSS 9.8.&lt;/p>
&lt;h3 id="what-is-epss">What is EPSS?&lt;/h3>
&lt;p>The Exploit Prediction Scoring System (EPSS) is a model maintained by FIRST.org that estimates the probability that a CVE will be exploited in the wild in the next 30 days. EPSS scores range from 0 to 1 (0% to 100% probability). Used alongside CVSS and KEV, EPSS provides a forward-looking signal for vulnerability prioritization.&lt;/p></description><category>education</category></item><item><title>SBOM Scanning: How to Detect Vulnerabilities in Your Software Components</title><link>https://sbomify.com/2026/02/01/sbom-scanning-vulnerability-detection/</link><pubDate>Sun, 01 Feb 2026 00:00:00 +0000</pubDate><guid>https://sbomify.com/2026/02/01/sbom-scanning-vulnerability-detection/</guid><description>&lt;p>SBOM scanning is the process of analyzing a &lt;a href="https://sbomify.com/what-is-sbom/">Software Bill of Materials&lt;/a> to identify known vulnerabilities, license issues, and other risks in the components listed within it. Rather than re-analyzing source code or container images for each new vulnerability disclosure, SBOM scanning matches the component inventory already documented in your SBOM against vulnerability databases. This makes it possible to continuously monitor your entire software portfolio for newly disclosed threats without rescanning every artifact.&lt;/p>
&lt;h2 id="how-sbom-scanning-works">How SBOM Scanning Works&lt;/h2>
&lt;p>The SBOM scanning workflow has three stages:&lt;/p>
&lt;h3 id="1-component-identification">1. Component Identification&lt;/h3>
&lt;p>The scanner reads the SBOM and extracts component identifiers — primarily &lt;a href="https://github.com/package-url/purl-spec">Package URLs (purls)&lt;/a> and &lt;a href="https://nvd.nist.gov/products/cpe">CPEs&lt;/a> — along with version information. These identifiers are the keys used to look up vulnerability data.&lt;/p>
&lt;p>A purl like &lt;code>pkg:npm/lodash@4.17.20&lt;/code> tells the scanner exactly which package (lodash), from which registry (npm), at which version (4.17.20) to check. The more precise your SBOM&amp;rsquo;s identifiers, the more accurate the scan results.&lt;/p>
&lt;h3 id="2-database-matching">2. Database Matching&lt;/h3>
&lt;p>The scanner queries one or more vulnerability databases to find known &lt;a href="https://sbomify.com/2025/12/18/cve-vulnerability-explained/">CVEs&lt;/a> affecting the identified components. Major databases include:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://nvd.nist.gov/">National Vulnerability Database (NVD)&lt;/a>&lt;/strong> — The U.S. government&amp;rsquo;s comprehensive CVE database with &lt;a href="https://sbomify.com/2026/02/05/what-is-cvss-vulnerability-scoring/">CVSS&lt;/a> severity scores&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://osv.dev/">OSV (Open Source Vulnerabilities)&lt;/a>&lt;/strong> — Google&amp;rsquo;s database focused on open source package vulnerabilities, with ecosystem-specific advisory data&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://github.com/advisories">GitHub Advisory Database&lt;/a>&lt;/strong> — Community-curated advisories with package-manager-specific versioning&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA KEV Catalog&lt;/a>&lt;/strong> — The list of vulnerabilities with confirmed &lt;a href="https://sbomify.com/2025/12/30/what-is-kev-cisa-known-exploited-vulnerabilities/">active exploitation&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="3-result-reporting">3. Result Reporting&lt;/h3>
&lt;p>The scanner produces a report listing each vulnerability found, typically including:&lt;/p>
&lt;ul>
&lt;li>The affected component and version&lt;/li>
&lt;li>The CVE identifier&lt;/li>
&lt;li>The CVSS severity score&lt;/li>
&lt;li>Whether the vulnerability is listed in the CISA KEV catalog&lt;/li>
&lt;li>Fix availability (which version resolves the vulnerability)&lt;/li>
&lt;li>Advisory details and references&lt;/li>
&lt;/ul>
&lt;h2 id="sbom-scanning-tools">SBOM Scanning Tools&lt;/h2>
&lt;h3 id="grype">Grype&lt;/h3>
&lt;p>&lt;a href="https://github.com/anchore/grype">Grype&lt;/a> is an open source vulnerability scanner from Anchore that accepts SBOMs as direct input. It is designed to work with SBOMs generated by &lt;a href="https://github.com/anchore/syft">Syft&lt;/a> but supports any CycloneDX or SPDX SBOM.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Scan an SBOM file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grype sbom:./my-sbom.cdx.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Scan an SBOM with specific output format&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grype sbom:./my-sbom.spdx.json -o table
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Grype matches against multiple vulnerability databases including the NVD, OSV, and ecosystem-specific advisories. It runs as a CLI tool, making it straightforward to integrate into CI/CD pipelines.&lt;/p>
&lt;h3 id="owasp-dependency-track">OWASP Dependency-Track&lt;/h3>
&lt;p>&lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a> is a continuous SBOM analysis platform. Unlike CLI scanners that run once, Dependency-Track ingests SBOMs into a persistent database and continuously re-evaluates them as new vulnerabilities are published.&lt;/p>
&lt;p>Key capabilities:&lt;/p>
&lt;ul>
&lt;li>Ingests SBOMs in CycloneDX and SPDX formats via API or web upload&lt;/li>
&lt;li>Monitors against NVD, OSV, GitHub Advisories, and other sources&lt;/li>
&lt;li>Provides a dashboard showing risk across your entire portfolio&lt;/li>
&lt;li>Sends notifications when new vulnerabilities affect your components&lt;/li>
&lt;li>Supports policy management for automated risk evaluation&lt;/li>
&lt;/ul>
&lt;p>Dependency-Track is particularly valuable for &lt;a href="https://sbomify.com/2026/01/18/sbom-management-best-practices/">SBOM management&lt;/a> at scale — it maintains a centralized view of all your software components and their vulnerability status.&lt;/p>
&lt;h3 id="osv-scanner">OSV-Scanner&lt;/h3>
&lt;p>&lt;a href="https://google.github.io/osv-scanner/">OSV-Scanner&lt;/a> from Google uses the &lt;a href="https://osv.dev/">OSV database&lt;/a> and supports SBOM input. It focuses on open source package vulnerabilities with ecosystem-specific version matching.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Scan an SBOM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>osv-scanner scan source -S my-sbom.cdx.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="trivy">Trivy&lt;/h3>
&lt;p>&lt;a href="https://github.com/aquasecurity/trivy">Trivy&lt;/a> can scan SBOMs for vulnerabilities in addition to its source directory and container image scanning capabilities.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Scan an SBOM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trivy sbom my-sbom.cdx.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="sbomify">sbomify&lt;/h3>
&lt;p>&lt;a href="https://sbomify.com">sbomify&lt;/a> integrates vulnerability monitoring directly into its SBOM management platform. When you upload SBOMs to sbomify, they are automatically scanned against &lt;a href="https://osv.dev/">Google OSV&lt;/a> for known vulnerabilities. For organizations needing deeper analysis, sbomify also integrates with &lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a>. This means generation, storage, scanning, and distribution happen in a single workflow rather than requiring separate tools.&lt;/p>
&lt;p>For a broader tool comparison, see our &lt;a href="https://sbomify.com/2026/01/26/sbom-generation-tools-comparison/">SBOM generation tools guide&lt;/a> and &lt;a href="https://sbomify.com/resources/">resources page&lt;/a>.&lt;/p>
&lt;h2 id="setting-up-continuous-monitoring">Setting Up Continuous Monitoring&lt;/h2>
&lt;p>Point-in-time scanning catches vulnerabilities known at scan time but misses those disclosed afterward. Continuous monitoring solves this by repeatedly matching your SBOMs against updated vulnerability databases.&lt;/p>
&lt;h3 id="the-workflow">The Workflow&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>Generate SBOMs&lt;/strong> in your CI/CD pipeline with every build using tools from our &lt;a href="https://sbomify.com/guides/">SBOM generation guides&lt;/a>&lt;/li>
&lt;li>&lt;strong>Ingest SBOMs&lt;/strong> into a monitoring platform (&lt;a href="https://sbomify.com">sbomify&lt;/a>, OWASP Dependency-Track, or equivalent)&lt;/li>
&lt;li>&lt;strong>Configure data sources&lt;/strong> — connect the platform to NVD, OSV, KEV, and ecosystem-specific advisory feeds&lt;/li>
&lt;li>&lt;strong>Set up notifications&lt;/strong> — alert the appropriate team when new vulnerabilities are found in their components&lt;/li>
&lt;li>&lt;strong>Define policies&lt;/strong> — establish severity thresholds and SLAs for remediation&lt;/li>
&lt;/ol>
&lt;h3 id="why-continuous-monitoring-matters">Why Continuous Monitoring Matters&lt;/h3>
&lt;p>New CVEs are published daily. A component that was clean when you deployed it may have a critical vulnerability disclosed a week later. Without continuous monitoring, you will not know until the next scheduled scan — which may be too late.&lt;/p>
&lt;p>The &lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA KEV catalog&lt;/a> is updated multiple times per week with vulnerabilities that are actively being exploited. Continuous monitoring against KEV ensures you are alerted immediately when a component in your portfolio is under active attack.&lt;/p>
&lt;h2 id="acting-on-scan-results">Acting on Scan Results&lt;/h2>
&lt;p>Scanning without action is overhead. An effective vulnerability response process turns scan results into remediation.&lt;/p>
&lt;h3 id="prioritization">Prioritization&lt;/h3>
&lt;p>Not all vulnerabilities require immediate action. Prioritize based on:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>KEV status.&lt;/strong> If the vulnerability is in the &lt;a href="https://sbomify.com/2025/12/30/what-is-kev-cisa-known-exploited-vulnerabilities/">CISA KEV catalog&lt;/a>, it is being actively exploited — treat it as urgent regardless of CVSS score.&lt;/li>
&lt;li>&lt;strong>CVSS severity.&lt;/strong> Critical (9.0-10.0) and High (7.0-8.9) vulnerabilities warrant faster response. See our &lt;a href="https://sbomify.com/2026/02/05/what-is-cvss-vulnerability-scoring/">CVSS guide&lt;/a> for scoring details.&lt;/li>
&lt;li>&lt;strong>Exploitability.&lt;/strong> Is there a public exploit? Is the vulnerability exploitable remotely without authentication?&lt;/li>
&lt;li>&lt;strong>Deployment context.&lt;/strong> Is the affected component in an internet-facing application or an internal tool? Is the vulnerable code path actually reachable?&lt;/li>
&lt;li>&lt;strong>Fix availability.&lt;/strong> If a patched version exists, updating is straightforward. If no fix is available, you need a workaround or compensating control.&lt;/li>
&lt;/ol>
&lt;h3 id="remediation">Remediation&lt;/h3>
&lt;p>The most common remediation is updating the vulnerable component to a fixed version. For transitive dependencies, this may require updating the direct dependency that pulls it in — see our &lt;a href="https://sbomify.com/2026/01/29/what-is-a-dependency-in-software/">dependency guide&lt;/a> for details on dependency trees.&lt;/p>
&lt;p>When an update is not immediately possible:&lt;/p>
&lt;ul>
&lt;li>Apply vendor-recommended mitigations or workarounds&lt;/li>
&lt;li>Implement compensating controls (WAF rules, network restrictions)&lt;/li>
&lt;li>Document the accepted risk with a timeline for permanent remediation&lt;/li>
&lt;/ul>
&lt;h3 id="vex-vulnerability-exploitability-exchange">VEX (Vulnerability Exploitability eXchange)&lt;/h3>
&lt;p>VEX is a standardized way to communicate whether a vulnerability in a component actually affects a specific product. A VEX statement might declare that CVE-2024-XXXX in lodash &amp;ldquo;does not affect&amp;rdquo; your application because the vulnerable function is never called.&lt;/p>
&lt;p>VEX reduces false positives by distinguishing between &amp;ldquo;this component has a known CVE&amp;rdquo; and &amp;ldquo;this CVE actually impacts our product.&amp;rdquo; Both &lt;a href="https://cyclonedx.org/">CycloneDX&lt;/a> and &lt;a href="https://github.com/openvex">OpenVEX&lt;/a> support VEX documents that can be consumed by scanning tools to suppress known non-exploitable findings.&lt;/p>
&lt;h2 id="best-practices">Best Practices&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Scan SBOMs, not just source code.&lt;/strong> SBOM scanning catches vulnerabilities in deployed components, including OS-level packages in &lt;a href="https://sbomify.com/2026/01/03/container-security-best-practices/">containers&lt;/a> that do not appear in your source repository.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Monitor continuously.&lt;/strong> Do not rely on scan-at-build-time alone. Use a platform like &lt;a href="https://sbomify.com">sbomify&lt;/a> or OWASP Dependency-Track for ongoing monitoring against updated vulnerability feeds.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Prioritize with KEV.&lt;/strong> Use the CISA KEV catalog as a top-priority signal. KEV-listed vulnerabilities are confirmed to be actively exploited and should be remediated first.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Define SLAs.&lt;/strong> Establish clear timelines for remediation based on severity and exploitability. Example: KEV-listed critical vulnerabilities within 48 hours; critical non-KEV within 2 weeks; high severity within 30 days.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Use VEX to reduce noise.&lt;/strong> When a vulnerability does not affect your product (because the vulnerable code path is not reachable), document this with a VEX statement rather than suppressing the alert entirely.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Automate the pipeline.&lt;/strong> Generate SBOMs automatically in CI/CD, ingest them into monitoring automatically, and route alerts to the right teams automatically. Manual steps create gaps.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="frequently-asked-questions">Frequently Asked Questions&lt;/h2>
&lt;h3 id="what-is-sbom-scanning">What is SBOM scanning?&lt;/h3>
&lt;p>SBOM scanning is the process of analyzing a Software Bill of Materials to identify known vulnerabilities, license issues, and other risks in the components it documents. Scanners match SBOM component identifiers (purls, CPEs) against vulnerability databases like the NVD and OSV to find known CVEs. This enables continuous vulnerability monitoring without repeatedly scanning source code or container images.&lt;/p>
&lt;h3 id="what-tools-scan-sboms-for-vulnerabilities">What tools scan SBOMs for vulnerabilities?&lt;/h3>
&lt;p>Leading SBOM scanning tools include &lt;a href="https://sbomify.com">sbomify&lt;/a> (integrated platform with built-in OSV and Dependency-Track scanning), Grype (CLI scanner from Anchore), OWASP Dependency-Track (standalone monitoring platform), OSV-Scanner (Google&amp;rsquo;s open source scanner), and Trivy (comprehensive security scanner from Aqua Security). Grype and Trivy are best for CI/CD pipeline integration; sbomify and Dependency-Track are best for ongoing portfolio monitoring.&lt;/p>
&lt;h3 id="how-often-should-i-scan-my-sboms">How often should I scan my SBOMs?&lt;/h3>
&lt;p>SBOMs should be scanned continuously, not just at build time. New vulnerabilities are disclosed daily, and a component that was clean at build time may have a critical CVE disclosed afterward. Use a continuous monitoring platform that automatically re-evaluates your SBOMs as vulnerability databases are updated.&lt;/p>
&lt;h3 id="what-is-the-difference-between-sbom-scanning-and-sca">What is the difference between SBOM scanning and SCA?&lt;/h3>
&lt;p>&lt;a href="https://sbomify.com/2026/01/11/software-composition-analysis-sca/">Software Composition Analysis (SCA)&lt;/a> scans source code, dependency files, or binaries to identify components and their vulnerabilities. SBOM scanning takes an already-generated SBOM as input and matches its components against vulnerability databases. SCA produces the inventory; SBOM scanning monitors it over time. They are complementary — SCA for discovery, SBOM scanning for continuous monitoring.&lt;/p>
&lt;h3 id="what-is-vex">What is VEX?&lt;/h3>
&lt;p>VEX (Vulnerability Exploitability eXchange) is a standardized format for communicating whether a known vulnerability in a component actually affects a specific product. A VEX statement can declare that a CVE &amp;ldquo;does not affect,&amp;rdquo; &amp;ldquo;is under investigation,&amp;rdquo; or &amp;ldquo;is affected&amp;rdquo; in your product. VEX reduces false positives from SBOM scanning by distinguishing theoretical vulnerability from actual impact.&lt;/p></description><category>education</category></item><item><title>What Is a Dependency in Software? A Beginner&amp;#39;s Guide</title><link>https://sbomify.com/2026/01/29/what-is-a-dependency-in-software/</link><pubDate>Thu, 29 Jan 2026 00:00:00 +0000</pubDate><guid>https://sbomify.com/2026/01/29/what-is-a-dependency-in-software/</guid><description>&lt;p>A dependency in software is any external component — a library, framework, module, or package — that your application relies on to function. When you import a package from npm, add a library from PyPI, or include a Maven artifact, you are adding a dependency. Dependencies allow developers to reuse tested, maintained code rather than writing everything from scratch. Modern applications are built overwhelmingly from dependencies: studies consistently show that &lt;a href="https://www.linux.com/training-tutorials/estimating-total-number-linux-contributors-approach-using-linus-law/">70-90% of a typical application consists of open source components&lt;/a>.&lt;/p>
&lt;h2 id="direct-vs-transitive-dependencies">Direct vs. Transitive Dependencies&lt;/h2>
&lt;p>The most important distinction in dependency management is between direct and transitive dependencies.&lt;/p>
&lt;p>&lt;strong>Direct dependencies&lt;/strong> are the packages your project explicitly declares. These appear in your dependency manifest — &lt;code>package.json&lt;/code> for JavaScript, &lt;code>requirements.txt&lt;/code> or &lt;code>pyproject.toml&lt;/code> for Python, &lt;code>pom.xml&lt;/code> for Java, &lt;code>go.mod&lt;/code> for Go, &lt;code>Cargo.toml&lt;/code> for Rust, and similar files for other ecosystems. You chose these packages, you decided which versions to use, and you are (presumably) aware of their purpose in your application.&lt;/p>
&lt;p>&lt;strong>Transitive dependencies&lt;/strong> are the dependencies of your dependencies. When you add package A to your project, and package A depends on packages B and C, and package B depends on package D, then B, C, and D are all transitive dependencies of your project. You may never have heard of packages B, C, or D, yet they are running in your application and their vulnerabilities are your vulnerabilities.&lt;/p>
&lt;h3 id="the-scale-of-transitive-dependencies">The Scale of Transitive Dependencies&lt;/h3>
&lt;p>The ratio of transitive to direct dependencies is often surprising:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Ecosystem&lt;/th>
&lt;th>Typical direct dependencies&lt;/th>
&lt;th>Typical total (including transitive)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>JavaScript&lt;/td>
&lt;td>20-50&lt;/td>
&lt;td>200-1,500+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Python&lt;/td>
&lt;td>10-30&lt;/td>
&lt;td>50-200&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Java/Maven&lt;/td>
&lt;td>10-30&lt;/td>
&lt;td>100-500&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Go&lt;/td>
&lt;td>10-30&lt;/td>
&lt;td>50-300&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Rust/Cargo&lt;/td>
&lt;td>10-30&lt;/td>
&lt;td>100-400&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>A JavaScript project with 30 direct dependencies may pull in over 1,000 transitive packages through the npm dependency tree. Each of those packages is code running in your application, with its own maintenance status, license, and vulnerability history.&lt;/p>
&lt;h2 id="the-dependency-tree">The Dependency Tree&lt;/h2>
&lt;p>A dependency tree (or dependency graph) is the complete set of relationships between a project and all of its dependencies, both direct and transitive. Visualizing this tree reveals the full scope of what your application depends on.&lt;/p>
&lt;pre tabindex="0">&lt;code>my-application
├── express@4.18.2 (direct)
│ ├── body-parser@1.20.2 (transitive)
│ │ ├── bytes@3.1.2
│ │ └── iconv-lite@0.4.24
│ │ └── safer-buffer@2.1.2
│ ├── cookie@0.5.0
│ └── ...
├── lodash@4.17.21 (direct)
└── axios@1.6.2 (direct)
└── follow-redirects@1.15.3 (transitive)
&lt;/code>&lt;/pre>&lt;p>In this example, &lt;code>express&lt;/code>, &lt;code>lodash&lt;/code>, and &lt;code>axios&lt;/code> are direct dependencies. Everything nested beneath them is transitive. The vulnerability in &lt;code>safer-buffer&lt;/code> — four levels deep — is just as dangerous as one in &lt;code>express&lt;/code> itself.&lt;/p>
&lt;h2 id="why-dependencies-matter-for-security">Why Dependencies Matter for Security&lt;/h2>
&lt;p>Dependencies are the primary attack surface for most applications. Several high-profile incidents illustrate the risks:&lt;/p>
&lt;h3 id="vulnerable-dependencies">Vulnerable Dependencies&lt;/h3>
&lt;p>The &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-44228">Log4Shell vulnerability&lt;/a> (&lt;a href="https://sbomify.com/2025/12/18/cve-vulnerability-explained/">CVE-2021-44228&lt;/a>) in the Apache Log4j logging library affected millions of Java applications. Many organizations did not know they used Log4j because it was a transitive dependency — pulled in by frameworks and libraries they did depend on directly.&lt;/p>
&lt;h3 id="compromised-dependencies">Compromised Dependencies&lt;/h3>
&lt;p>The &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2024-3094">XZ Utils backdoor&lt;/a> demonstrated that attackers can spend years gaining trust in a legitimate open source project before inserting malicious code. When a dependency is compromised, every application that uses it is affected.&lt;/p>
&lt;h3 id="abandoned-dependencies">Abandoned Dependencies&lt;/h3>
&lt;p>Dependencies that are no longer maintained represent a growing risk. When a &lt;a href="https://sbomify.com/2025/12/18/cve-vulnerability-explained/">CVE&lt;/a> is found in an unmaintained package, there may be no one to produce a patch. The component stays vulnerable indefinitely unless consumers fork it or find an alternative.&lt;/p>
&lt;h3 id="dependency-confusion">Dependency Confusion&lt;/h3>
&lt;p>Dependency confusion attacks exploit the way package managers resolve names. An attacker publishes a malicious package to a public registry with the same name as a private internal package. If the package manager checks the public registry first (or alongside) the private one, it may install the attacker&amp;rsquo;s package instead.&lt;/p>
&lt;p>For a deeper discussion of supply chain attacks, see our &lt;a href="https://sbomify.com/2025/12/26/software-supply-chain-management/">software supply chain management guide&lt;/a>.&lt;/p>
&lt;h2 id="lock-files">Lock Files&lt;/h2>
&lt;p>Lock files are a critical tool for dependency management. They record the exact versions of every dependency (direct and transitive) that were resolved during installation, ensuring that subsequent installations produce identical results.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Ecosystem&lt;/th>
&lt;th>Lock File&lt;/th>
&lt;th>Manifest File&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>JavaScript&lt;/td>
&lt;td>&lt;code>package-lock.json&lt;/code>&lt;/td>
&lt;td>&lt;code>package.json&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Python&lt;/td>
&lt;td>&lt;code>poetry.lock&lt;/code>&lt;/td>
&lt;td>&lt;code>pyproject.toml&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Rust&lt;/td>
&lt;td>&lt;code>Cargo.lock&lt;/code>&lt;/td>
&lt;td>&lt;code>Cargo.toml&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Go&lt;/td>
&lt;td>&lt;code>go.sum&lt;/code>&lt;/td>
&lt;td>&lt;code>go.mod&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ruby&lt;/td>
&lt;td>&lt;code>Gemfile.lock&lt;/code>&lt;/td>
&lt;td>&lt;code>Gemfile&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PHP&lt;/td>
&lt;td>&lt;code>composer.lock&lt;/code>&lt;/td>
&lt;td>&lt;code>composer.json&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Without a lock file, the same manifest can resolve to different dependency versions on different machines or at different times. This non-determinism is both a reliability risk (builds may break unpredictably) and a security risk (a newly published malicious version could be pulled in automatically).&lt;/p>
&lt;p>Lock files should always be committed to version control. They are the source of truth for what is actually installed in your project.&lt;/p>
&lt;h2 id="how-sboms-document-dependencies">How SBOMs Document Dependencies&lt;/h2>
&lt;p>A &lt;a href="https://sbomify.com/what-is-sbom/">Software Bill of Materials&lt;/a> provides a complete, machine-readable inventory of every component in your software, including all transitive dependencies. This is essential for security because:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Full visibility.&lt;/strong> An SBOM documents every package in the dependency tree, not just the direct dependencies listed in your manifest file. This is the only reliable way to know everything running in your application.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Vulnerability matching.&lt;/strong> Once you have an SBOM, platforms like &lt;a href="https://sbomify.com">sbomify&lt;/a> can continuously monitor every component against vulnerability databases. CLI tools like &lt;a href="https://github.com/anchore/grype">Grype&lt;/a> and &lt;a href="https://google.github.io/osv-scanner/">OSV-Scanner&lt;/a> provide point-in-time scanning, while &lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a> offers standalone continuous monitoring. See our &lt;a href="https://sbomify.com/2026/02/01/sbom-scanning-vulnerability-detection/">SBOM scanning guide&lt;/a> for details and our &lt;a href="https://sbomify.com/resources/">resources page&lt;/a> for a complete list of tools.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Dependency relationship mapping.&lt;/strong> Both &lt;a href="https://cyclonedx.org/">CycloneDX&lt;/a> and &lt;a href="https://spdx.dev/">SPDX&lt;/a> support dependency relationship data, documenting which components depend on which others. This lets you trace the path from a vulnerable transitive dependency back to the direct dependency that brought it in.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>License tracking.&lt;/strong> Each dependency carries a license. SBOMs document these licenses, enabling automated compliance checking. A single &lt;a href="https://sbomify.com/2025/12/22/gpl-license-guide/">GPL-licensed&lt;/a> transitive dependency can trigger copyleft obligations for your entire application.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>SBOM generation tools like the &lt;a href="https://github.com/sbomify/github-action/">sbomify GitHub Action&lt;/a>, &lt;a href="https://github.com/anchore/syft">Syft&lt;/a>, and &lt;a href="https://github.com/aquasecurity/trivy">Trivy&lt;/a> analyze lock files and build artifacts to capture the full dependency tree. For language-specific SBOM generation instructions, see our &lt;a href="https://sbomify.com/guides/">SBOM guides&lt;/a>.&lt;/p>
&lt;h2 id="best-practices">Best Practices&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Always use and commit lock files.&lt;/strong> Lock files ensure reproducible builds and prevent unexpected dependency changes. Review lock file diffs in pull requests to catch unintended dependency updates.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Audit your dependency tree regularly.&lt;/strong> Use &lt;code>npm audit&lt;/code>, &lt;code>pip-audit&lt;/code>, &lt;code>cargo audit&lt;/code>, or equivalent tools to check for known vulnerabilities. Do not limit auditing to direct dependencies — transitive vulnerabilities are equally dangerous.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Minimize your dependency footprint.&lt;/strong> Every dependency is a potential risk vector. Before adding a new package, evaluate whether the functionality justifies the added surface area. Prefer well-maintained libraries with active security response processes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Generate and monitor SBOMs.&lt;/strong> Automate SBOM generation in your CI/CD pipeline and monitor SBOMs continuously against vulnerability databases. This catches newly disclosed CVEs in your existing dependencies. See our &lt;a href="https://sbomify.com/2026/01/18/sbom-management-best-practices/">SBOM management guide&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Keep dependencies up to date.&lt;/strong> Apply security updates promptly, especially for dependencies listed in the &lt;a href="https://sbomify.com/2025/12/30/what-is-kev-cisa-known-exploited-vulnerabilities/">CISA KEV catalog&lt;/a>. Use tools like Dependabot or Renovate to automate update pull requests.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Review dependency changes.&lt;/strong> Treat dependency updates in pull requests with the same scrutiny as code changes. A bumped version may introduce new transitive dependencies, change licenses, or include unexpected modifications.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="frequently-asked-questions">Frequently Asked Questions&lt;/h2>
&lt;h3 id="what-is-a-dependency-in-software">What is a dependency in software?&lt;/h3>
&lt;p>A dependency is any external component — a library, framework, module, or package — that your application relies on to function. Dependencies are declared in manifest files (like &lt;code>package.json&lt;/code> or &lt;code>requirements.txt&lt;/code>) and installed from package registries (like npm or PyPI). They allow developers to reuse existing code rather than building everything from scratch.&lt;/p>
&lt;h3 id="what-is-a-transitive-dependency">What is a transitive dependency?&lt;/h3>
&lt;p>A transitive dependency is a dependency of your dependency. If your project depends on package A, and package A depends on package B, then B is a transitive dependency of your project. Transitive dependencies are often invisible to developers but can contain vulnerabilities, restrictive licenses, or outdated code. They typically outnumber direct dependencies by a factor of 5-30x depending on the ecosystem.&lt;/p>
&lt;h3 id="what-is-a-dependency-tree">What is a dependency tree?&lt;/h3>
&lt;p>A dependency tree (or dependency graph) is the complete hierarchy of all dependencies in a project, showing both direct and transitive relationships. It reveals the full set of code that your application actually uses at runtime. SBOM generation tools analyze dependency trees to produce complete component inventories.&lt;/p>
&lt;h3 id="why-are-dependencies-a-security-risk">Why are dependencies a security risk?&lt;/h3>
&lt;p>Dependencies are a security risk because each one introduces code that your team did not write and may not audit. Known vulnerabilities in dependencies (CVEs) are a primary attack vector — incidents like Log4Shell affected millions of applications through a single widely-used library. Dependencies can also be intentionally compromised (as in the XZ Utils backdoor), abandoned by maintainers, or used in dependency confusion attacks.&lt;/p>
&lt;h3 id="what-is-a-lock-file">What is a lock file?&lt;/h3>
&lt;p>A lock file records the exact resolved versions of all dependencies (direct and transitive) in a project. Examples include &lt;code>package-lock.json&lt;/code> (npm), &lt;code>poetry.lock&lt;/code> (Python), and &lt;code>Cargo.lock&lt;/code> (Rust). Lock files ensure reproducible builds — the same versions are installed every time, on every machine. They should always be committed to version control.&lt;/p></description><category>education</category></item><item><title>Software Composition Analysis (SCA): What It Is and How SBOMs Fit In</title><link>https://sbomify.com/2026/01/11/software-composition-analysis-sca/</link><pubDate>Sun, 11 Jan 2026 00:00:00 +0000</pubDate><guid>https://sbomify.com/2026/01/11/software-composition-analysis-sca/</guid><description>&lt;p>Software Composition Analysis (SCA) is a category of application security tooling that identifies open source and third-party components in a codebase, catalogs their licenses, and detects known vulnerabilities associated with those components. SCA tools work by analyzing dependency manifests, lock files, and sometimes compiled binaries to produce an inventory of components that can be matched against vulnerability databases like the &lt;a href="https://nvd.nist.gov/">National Vulnerability Database&lt;/a> (NVD) and the &lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA KEV catalog&lt;/a>.&lt;/p>
&lt;p>&lt;img src="https://sbomify.com/assets/images/d2/sca-workflow.svg" alt="SCA workflow from source analysis through component identification to vulnerability matching">&lt;/p>
&lt;h2 id="what-is-software-composition-analysis">What Is Software Composition Analysis?&lt;/h2>
&lt;p>Software Composition Analysis addresses a fundamental reality of modern software development: most applications are not written from scratch. Studies consistently show that &lt;a href="https://www.linux.com/training-tutorials/estimating-total-number-linux-contributors-approach-using-linus-law/">70-90% of a typical application consists of open source components&lt;/a> pulled from package registries like npm, PyPI, Maven Central, and crates.io. Each of these components introduces potential security vulnerabilities, license obligations, and maintenance risks.&lt;/p>
&lt;p>SCA tools automate the process of identifying these components and their associated risks. Without SCA, development teams would need to manually track every library version across every project — an approach that does not scale given the pace of vulnerability disclosure (the NVD published over 28,000 CVEs in 2023 alone).&lt;/p>
&lt;p>The core functions of SCA are:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Component identification.&lt;/strong> Scanning source code, dependency files, and sometimes binaries to produce a complete inventory of third-party components, including &lt;a href="https://sbomify.com/2026/01/29/what-is-a-dependency-in-software/">transitive dependencies&lt;/a> — the dependencies of your dependencies.&lt;/li>
&lt;li>&lt;strong>Vulnerability detection.&lt;/strong> Matching identified components against vulnerability databases to flag known &lt;a href="https://sbomify.com/2025/12/18/cve-vulnerability-explained/">CVEs&lt;/a>.&lt;/li>
&lt;li>&lt;strong>License compliance.&lt;/strong> Identifying the license of each component and flagging potential conflicts or compliance obligations, such as &lt;a href="https://sbomify.com/2025/12/22/gpl-license-guide/">GPL copyleft requirements&lt;/a>.&lt;/li>
&lt;li>&lt;strong>Policy enforcement.&lt;/strong> Allowing organizations to define rules (e.g., &amp;ldquo;block any component with a critical CVE&amp;rdquo; or &amp;ldquo;reject AGPL-licensed dependencies&amp;rdquo;) and enforce them in CI/CD pipelines.&lt;/li>
&lt;/ol>
&lt;h2 id="how-sca-tools-work">How SCA Tools Work&lt;/h2>
&lt;p>SCA tools typically operate through one or more of these analysis methods:&lt;/p>
&lt;h3 id="manifest-and-lock-file-analysis">Manifest and Lock File Analysis&lt;/h3>
&lt;p>The most common approach. SCA tools parse dependency declaration files — &lt;code>package.json&lt;/code> and &lt;code>package-lock.json&lt;/code> (JavaScript), &lt;code>requirements.txt&lt;/code> and &lt;code>poetry.lock&lt;/code> (Python), &lt;code>pom.xml&lt;/code> (Java), &lt;code>go.sum&lt;/code> (Go), &lt;code>Cargo.lock&lt;/code> (Rust), and similar files for other ecosystems. This provides a definitive list of declared dependencies and their resolved versions.&lt;/p>
&lt;h3 id="source-code-scanning">Source Code Scanning&lt;/h3>
&lt;p>Some SCA tools scan source code files to detect component usage that may not be declared in manifests — for example, vendored code (source files copied directly into a repository rather than managed through a package manager), or code snippets pulled from Stack Overflow or other sources.&lt;/p>
&lt;h3 id="binary-analysis">Binary Analysis&lt;/h3>
&lt;p>Binary SCA analyzes compiled artifacts (executables, container images, firmware) to identify embedded components. This is essential when source code is not available, such as when evaluating third-party commercial software or auditing firmware. Binary analysis is less precise than manifest analysis but covers a broader set of use cases.&lt;/p>
&lt;h3 id="dependency-resolution">Dependency Resolution&lt;/h3>
&lt;p>Advanced SCA tools resolve the full dependency tree, including transitive dependencies. A project that declares 10 direct dependencies may actually depend on hundreds of transitive packages. SCA tools that only examine direct dependencies miss the majority of the attack surface.&lt;/p>
&lt;h2 id="sca-vs-sast-vs-dast">SCA vs. SAST vs. DAST&lt;/h2>
&lt;p>SCA is one of several application security testing approaches. Each addresses different risk categories and operates at different points in the &lt;a href="https://sbomify.com/2025/12/15/software-development-life-cycle-sdlc-sbom-integration/">software development life cycle&lt;/a>.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Aspect&lt;/th>
&lt;th>SCA&lt;/th>
&lt;th>SAST&lt;/th>
&lt;th>DAST&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>What it analyzes&lt;/strong>&lt;/td>
&lt;td>Third-party and open source components&lt;/td>
&lt;td>Your application&amp;rsquo;s source code&lt;/td>
&lt;td>Your running application&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Risk category&lt;/strong>&lt;/td>
&lt;td>Known vulnerabilities in dependencies, license compliance&lt;/td>
&lt;td>Code-level flaws (injection, logic errors)&lt;/td>
&lt;td>Runtime vulnerabilities (XSS, auth bypass)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>When it runs&lt;/strong>&lt;/td>
&lt;td>Build time / CI pipeline&lt;/td>
&lt;td>Build time / CI pipeline&lt;/td>
&lt;td>After deployment / in staging&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Input&lt;/strong>&lt;/td>
&lt;td>Dependency files, lock files, binaries&lt;/td>
&lt;td>Source code, bytecode&lt;/td>
&lt;td>Application URLs and endpoints&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Output&lt;/strong>&lt;/td>
&lt;td>Component inventory, CVE matches, license report&lt;/td>
&lt;td>Code-level vulnerability findings&lt;/td>
&lt;td>Runtime vulnerability findings&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>False positive rate&lt;/strong>&lt;/td>
&lt;td>Low (matches known CVEs to exact versions)&lt;/td>
&lt;td>Moderate to high&lt;/td>
&lt;td>Low to moderate&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Coverage gap&lt;/strong>&lt;/td>
&lt;td>Does not find flaws in your own code&lt;/td>
&lt;td>Does not find dependency vulnerabilities&lt;/td>
&lt;td>Does not find issues in code paths not exercised&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>These tools are complementary. A comprehensive application security program uses all three:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>SCA&lt;/strong> catches known vulnerabilities in the 70-90% of your application that you did not write&lt;/li>
&lt;li>&lt;strong>SAST&lt;/strong> catches coding flaws in the 10-30% that you did write&lt;/li>
&lt;li>&lt;strong>DAST&lt;/strong> catches runtime issues that only manifest in a deployed environment&lt;/li>
&lt;/ul>
&lt;h2 id="sca-tools">SCA Tools&lt;/h2>
&lt;p>Several tools provide SCA capabilities. The ecosystem spans open source and commercial offerings.&lt;/p>
&lt;h3 id="open-source-sca-tools">Open Source SCA Tools&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://github.com/anchore/grype">Grype&lt;/a>&lt;/strong> — Vulnerability scanner from Anchore that matches SBOMs and container images against vulnerability databases. Works well in combination with Syft for SBOM generation.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://owasp.org/www-project-dependency-check/">OWASP Dependency-Check&lt;/a>&lt;/strong> — Mature OWASP project that identifies project dependencies and checks for known CVEs. Supports Java, .NET, JavaScript, Ruby, and Python.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a>&lt;/strong> — Continuous SBOM analysis platform that ingests SBOMs and monitors components against multiple vulnerability databases. Provides a dashboard for tracking risk across an entire portfolio.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://google.github.io/osv-scanner/">OSV-Scanner&lt;/a>&lt;/strong> — Google&amp;rsquo;s open source vulnerability scanner that uses the &lt;a href="https://osv.dev/">OSV database&lt;/a> and supports multiple ecosystems.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://github.com/aquasecurity/trivy">Trivy&lt;/a>&lt;/strong> — Comprehensive scanner from Aqua Security that detects vulnerabilities in OS packages, language dependencies, container images, and IaC configurations.&lt;/li>
&lt;/ul>
&lt;h3 id="commercial-sca-tools">Commercial SCA Tools&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Snyk Open Source&lt;/strong> — Developer-focused SCA with IDE integrations and automated fix PRs&lt;/li>
&lt;li>&lt;strong>Sonatype Lifecycle&lt;/strong> — Enterprise SCA with policy engine and supply chain firewall&lt;/li>
&lt;li>&lt;strong>Black Duck&lt;/strong> (Synopsys) — Enterprise SCA with extensive binary analysis capabilities&lt;/li>
&lt;li>&lt;strong>FOSSA&lt;/strong> — SCA focused on license compliance and open source management&lt;/li>
&lt;/ul>
&lt;p>For a comprehensive list of tools in the SBOM ecosystem, see our &lt;a href="https://sbomify.com/resources/">resources page&lt;/a>.&lt;/p>
&lt;h2 id="sca-and-sboms">SCA and SBOMs&lt;/h2>
&lt;p>SCA tools and &lt;a href="https://sbomify.com/what-is-sbom/">SBOMs&lt;/a> are closely related but serve different purposes. Understanding the relationship helps you build a more effective security program.&lt;/p>
&lt;h3 id="sca-generates-sboms">SCA Generates SBOMs&lt;/h3>
&lt;p>Many SCA tools produce SBOMs as an output of their analysis. The &lt;a href="https://github.com/sbomify/github-action/">sbomify GitHub Action&lt;/a> generates SBOMs and automatically enriches them with license, hash, and lifecycle metadata from 11+ data sources. Standalone tools like &lt;a href="https://github.com/anchore/syft">Syft&lt;/a> and &lt;a href="https://github.com/aquasecurity/trivy">Trivy&lt;/a> also generate SBOMs in standard formats (&lt;a href="https://cyclonedx.org/">CycloneDX&lt;/a> or &lt;a href="https://spdx.dev/">SPDX&lt;/a>). In this sense, SCA is one of the primary methods for &lt;a href="https://sbomify.com/guides/">SBOM generation&lt;/a>.&lt;/p>
&lt;h3 id="sboms-enable-continuous-sca">SBOMs Enable Continuous SCA&lt;/h3>
&lt;p>A generated SBOM can be ingested by management platforms like &lt;a href="https://sbomify.com">sbomify&lt;/a> or &lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a> for continuous analysis. Instead of re-scanning your entire codebase every time a new CVE is published, the platform matches new vulnerabilities against your existing SBOM inventory. This is particularly valuable for monitoring production deployments where source code may not be readily accessible.&lt;/p>
&lt;h3 id="sboms-go-beyond-sca">SBOMs Go Beyond SCA&lt;/h3>
&lt;p>While SCA focuses on vulnerability detection and license compliance, SBOMs serve a broader purpose:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Regulatory compliance.&lt;/strong> Frameworks like &lt;a href="https://sbomify.com/compliance/eo-14028/">Executive Order 14028&lt;/a>, the &lt;a href="https://sbomify.com/compliance/eu-cra/">EU Cyber Resilience Act&lt;/a>, and &lt;a href="https://sbomify.com/compliance/fda-medical-device/">FDA medical device guidance&lt;/a> require SBOMs as a compliance artifact — not just SCA scan results.&lt;/li>
&lt;li>&lt;strong>Supply chain transparency.&lt;/strong> SBOMs document the provenance and composition of software for consumers, auditors, and regulators.&lt;/li>
&lt;li>&lt;strong>Incident response.&lt;/strong> When a vulnerability like &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-44228">Log4Shell&lt;/a> is disclosed, SBOMs allow you to immediately identify affected products without re-running scans.&lt;/li>
&lt;/ul>
&lt;p>For organizations building a security program, SCA tools are the engine and SBOMs are the artifact. Use SCA to scan and detect; use SBOMs to document, share, and continuously monitor.&lt;/p>
&lt;h2 id="best-practices">Best Practices&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Integrate SCA into CI/CD.&lt;/strong> Run SCA scans on every build and pull request. Catching vulnerable dependencies before they reach production is far less costly than remediating them after deployment.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Monitor continuously, not just at build time.&lt;/strong> New vulnerabilities are disclosed daily. Use SBOM-based monitoring with platforms like &lt;a href="https://sbomify.com">sbomify&lt;/a> or &lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a> to catch newly disclosed CVEs in your already-deployed components.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Resolve the full dependency tree.&lt;/strong> Ensure your SCA tool analyzes transitive dependencies, not just direct ones. The majority of vulnerable components in most projects are transitive.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Define and enforce policies.&lt;/strong> Establish clear rules for vulnerability severity thresholds, license restrictions, and acceptable risk. Automate enforcement in your pipeline to prevent policy violations from reaching production.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Combine SCA with SAST and DAST.&lt;/strong> SCA only finds known vulnerabilities in third-party code. Pair it with SAST for your own code and DAST for runtime testing to cover all three risk categories.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Generate SBOMs from SCA output.&lt;/strong> Use your SCA tool&amp;rsquo;s SBOM generation capability to produce machine-readable component inventories in &lt;a href="https://sbomify.com/2026/01/15/sbom-formats-cyclonedx-vs-spdx/">CycloneDX or SPDX format&lt;/a>. These SBOMs serve both security monitoring and compliance purposes.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="frequently-asked-questions">Frequently Asked Questions&lt;/h2>
&lt;h3 id="what-is-software-composition-analysis-1">What is software composition analysis?&lt;/h3>
&lt;p>Software Composition Analysis (SCA) is a category of security tooling that identifies open source and third-party components in your software, detects known vulnerabilities in those components by matching them against databases like the NVD, and catalogs their licenses for compliance purposes. SCA tools analyze dependency manifests, lock files, and sometimes binaries to produce a complete component inventory.&lt;/p>
&lt;h3 id="what-is-the-difference-between-sca-and-sast">What is the difference between SCA and SAST?&lt;/h3>
&lt;p>SCA analyzes third-party and open source components in your application for known vulnerabilities and license issues. SAST (Static Application Security Testing) analyzes your own source code for coding flaws like injection vulnerabilities, authentication bypasses, and logic errors. SCA covers the 70-90% of your application that is third-party code; SAST covers the code you wrote yourself. Both are needed for comprehensive application security.&lt;/p>
&lt;h3 id="how-does-sca-relate-to-sboms">How does SCA relate to SBOMs?&lt;/h3>
&lt;p>SCA tools are one of the primary methods for generating SBOMs. When an SCA tool scans your project and identifies all components, that inventory can be exported as an SBOM in standard formats like CycloneDX or SPDX. Conversely, SBOMs enable continuous SCA by providing a persistent component inventory that can be monitored against new vulnerability disclosures without re-scanning source code.&lt;/p>
&lt;h3 id="what-are-the-best-open-source-sca-tools">What are the best open source SCA tools?&lt;/h3>
&lt;p>Leading open source SCA tools include Grype (vulnerability scanner from Anchore), OWASP Dependency-Track (continuous SBOM analysis platform), OWASP Dependency-Check (mature CVE detection tool), OSV-Scanner (Google&amp;rsquo;s vulnerability scanner using the OSV database), and Trivy (comprehensive scanner from Aqua Security). Choice depends on your ecosystem, integration requirements, and whether you need CLI scanning, CI/CD integration, or continuous monitoring.&lt;/p>
&lt;h3 id="does-sca-find-all-vulnerabilities">Does SCA find all vulnerabilities?&lt;/h3>
&lt;p>No. SCA finds known vulnerabilities in third-party components — those that have been assigned CVE identifiers and added to vulnerability databases. It does not find zero-day vulnerabilities (those not yet publicly known), vulnerabilities in your own code, or runtime configuration issues. SCA should be combined with SAST, DAST, and penetration testing for comprehensive coverage.&lt;/p></description><category>education</category></item><item><title>CRA Explained: What the Cyber Resilience Act Means for Device Manufacturers</title><link>https://sbomify.com/2026/01/06/cra-explained-cyber-resilience-act-for-device-manufacturers/</link><pubDate>Tue, 06 Jan 2026 00:00:00 +0000</pubDate><guid>https://sbomify.com/2026/01/06/cra-explained-cyber-resilience-act-for-device-manufacturers/</guid><description>&lt;p>The EU Cyber Resilience Act (CRA) is transforming how device manufacturers approach cybersecurity. To break down what this means in practice, Viktor sat down with Sarah Fluchs on the Nerding Out with Viktor podcast.&lt;/p>
&lt;p>Sarah isn&amp;rsquo;t just any commentator on the CRA - she serves on the &lt;strong>EU Commission&amp;rsquo;s CRA expert group&lt;/strong>, giving her first-hand involvement in shaping this landmark regulation. With a PhD in security-by-design and years of experience in OT (Operational Technology) cybersecurity, she brings a rare blend of technical depth and policy insight.&lt;/p>
&lt;div class="video-embed-wrapper my-8 w-full max-w-3xl mx-auto">
&lt;div class="relative w-full overflow-hidden rounded-xl sm:rounded-2xl shadow-lg" style="padding-bottom: 56.25%;">
&lt;iframe
class="absolute top-0 left-0 w-full h-full border-0"
src="https://www.youtube-nocookie.com/embed/e9_bpsJKOL0"
title="CRA Explained: Cyber Resilience Act for Device Manufacturers"
allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
referrerpolicy="strict-origin-when-cross-origin"
allowfullscreen
loading="lazy">
&lt;/iframe>
&lt;/div>
&lt;/div>
&lt;script type="application/ld+json">
{
"@context": "https://schema.org",
"@type": "VideoObject",
"name": "CRA Explained: Cyber Resilience Act for Device Manufacturers",
"description": "Podcast episode with EU CRA expert Sarah Fluchs explaining SBOM requirements, the 5-year support mandate, and vulnerability management for device manufacturers.",
"thumbnailUrl": "https://img.youtube.com/vi/e9_bpsJKOL0/maxresdefault.jpg",
"uploadDate": "2026-01-06T00:00:00Z",
"embedUrl": "https://www.youtube.com/embed/e9_bpsJKOL0",
"contentUrl": "https://www.youtube.com/watch?v=e9_bpsJKOL0"
}
&lt;/script>
&lt;h2 id="sboms-are-non-negotiable-for-cra-compliance">SBOMs Are Non-Negotiable for CRA Compliance&lt;/h2>
&lt;p>Sarah is emphatic: &lt;strong>SBOMs are critical for CRA compliance&lt;/strong>. The regulation requires manufacturers to maintain full visibility into their software supply chain, and SBOMs are the mechanism to achieve this.&lt;/p>
&lt;p>But generating quality SBOMs is only half the battle. The real challenge lies in managing them over time - tracking versions, maintaining audit trails, and making software components traceable across complex supply chains. For manufacturers of long-lifecycle hardware, this represents a fundamental operational shift.&lt;/p>
&lt;p>This is exactly where proper tooling becomes essential. A platform like &lt;a href="">sbomify&lt;/a> addresses these challenges by providing:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Lifecycle management&lt;/strong> - Archive and track SBOMs across product versions and releases&lt;/li>
&lt;li>&lt;strong>Centralized portal&lt;/strong> - Manage all your security artifacts in one place, with full version history&lt;/li>
&lt;li>&lt;strong>Trust Center&lt;/strong> - Share SBOMs with stakeholders (customers, auditors, regulators) through a branded portal&lt;/li>
&lt;li>&lt;strong>CI/CD integration&lt;/strong> - Generate SBOMs automatically in your pipeline and upload them to sbomify&lt;/li>
&lt;/ul>
&lt;h2 id="the-5-year-support-requirement-changes-everything">The 5-Year Support Requirement Changes Everything&lt;/h2>
&lt;p>The CRA mandates security updates for the expected product lifetime, with a &lt;strong>minimum of five years&lt;/strong>. For OT devices that often operate for 20+ years, this forces companies to fundamentally rethink their approach.&lt;/p>
&lt;p>This isn&amp;rsquo;t just about patching - it&amp;rsquo;s about maintaining comprehensive records of what software was shipped, when, and to whom. You need to be able to answer: &amp;ldquo;What components were in version 2.3.1 that we shipped in 2024?&amp;rdquo; years down the line.&lt;/p>
&lt;p>This is where SBOM archiving becomes critical. With sbomify, every release is captured and stored, creating an auditable trail that satisfies CRA&amp;rsquo;s documentation requirements without manual tracking.&lt;/p>
&lt;h2 id="vulnerability-management-at-scale">Vulnerability Management at Scale&lt;/h2>
&lt;p>Manufacturers must establish robust vulnerability handling processes, including responsible disclosure mechanisms. Sarah notes that the hardest part isn&amp;rsquo;t formal reporting - it&amp;rsquo;s building an efficient system to triage the influx of vulnerability reports.&lt;/p>
&lt;p>sbomify integrates with vulnerability databases like &lt;a href="https://sbomify.com/features/integrations/">Google OSV&lt;/a> and &lt;a href="https://sbomify.com/features/integrations/">Dependency Track&lt;/a>, allowing you to continuously monitor your archived SBOMs for newly discovered vulnerabilities - even for products shipped years ago.&lt;/p>
&lt;h2 id="sarahs-key-message">Sarah&amp;rsquo;s Key Message&lt;/h2>
&lt;blockquote>
&lt;p>&amp;ldquo;CRA compliance isn&amp;rsquo;t about ticking boxes. Done right, it&amp;rsquo;s a path to stronger engineering practices, deeper supply chain accountability, and better product security.&amp;rdquo;&lt;/p>&lt;/blockquote>
&lt;p>Her advice for manufacturers getting started:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Find your showstoppers early&lt;/strong> - Run your products through the CRA requirements now to identify major blockers&lt;/li>
&lt;li>&lt;strong>Start your risk assessment&lt;/strong> - This is the linchpin that informs all other decisions&lt;/li>
&lt;li>&lt;strong>Establish vulnerability handling&lt;/strong> - Build the processes to manage the influx of security information&lt;/li>
&lt;/ol>
&lt;h2 id="listen-to-the-full-episode">Listen to the Full Episode&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://vpetersson.com/podcast/S02E21.html">Full episode with transcript&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=e9_bpsJKOL0">YouTube&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://open.spotify.com/show/2eoSJgEN0YOgshqYkqnX2B">Spotify&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://podcasts.apple.com/podcast/nerding-out-with-viktor/id1722663668">Apple Podcasts&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://music.amazon.com/podcasts/c2443912-6c23-4ce9-804c-4caa827f63d7/nerding-out-with-viktor">Amazon Music&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="get-cra-ready-with-sbomify">Get CRA-Ready with sbomify&lt;/h2>
&lt;p>The CRA deadline is approaching fast. &lt;a href="">sbomify&lt;/a> gives you the infrastructure to generate, manage, and share SBOMs throughout your product lifecycle - whether you&amp;rsquo;re shipping embedded devices, IoT products, or enterprise software.&lt;/p>
&lt;p>&lt;a href="https://app.sbomify.com">Get started free →&lt;/a>&lt;/p>
&lt;h2 id="related-resources">Related Resources&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://digital-strategy.ec.europa.eu/en/policies/cyber-resilience-act">EU Cyber Resilience Act - Official EU page&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sbomify.com/features/why-now/">Why Now? CRA is Coming&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sbomify.com/2024/07/10/understanding-the-eu-cyber-resilience-act-the-role-of-sboms-in-enhancing-cybersecurity/">Understanding the EU Cyber Resilience Act: The Role of SBOMs&lt;/a>&lt;/li>
&lt;/ul></description><category>podcast</category></item><item><title>Container Security: Best Practices for Securing Docker and Kubernetes</title><link>https://sbomify.com/2026/01/03/container-security-best-practices/</link><pubDate>Sat, 03 Jan 2026 00:00:00 +0000</pubDate><guid>https://sbomify.com/2026/01/03/container-security-best-practices/</guid><description>&lt;p>Container security is the practice of protecting containerized applications and their infrastructure throughout the entire lifecycle — from building container images through deployment and runtime operations. Containers package applications with their dependencies into isolated units, but this isolation does not automatically equal security. Every layer of a container image, from the base operating system to application dependencies, represents a potential attack surface that must be managed.&lt;/p>
&lt;p>&lt;img src="https://sbomify.com/assets/images/d2/container-security-layers.svg" alt="Container image layers with separate SBOMs feeding into security controls">&lt;/p>
&lt;h2 id="what-is-container-security">What Is Container Security?&lt;/h2>
&lt;p>Container security encompasses the tools, practices, and policies used to protect containerized workloads. Unlike traditional application security, container security must address concerns at multiple layers: the container image, the container runtime, the orchestration platform (typically Kubernetes), the host operating system, and the network.&lt;/p>
&lt;p>Containers have become the standard deployment model for cloud-native applications. According to the &lt;a href="https://www.cncf.io/">Cloud Native Computing Foundation&lt;/a>, the majority of organizations now run containerized workloads in production. This widespread adoption makes container security a critical discipline — a compromised container image pulled from a public registry can affect thousands of deployments.&lt;/p>
&lt;p>The challenge is compounded by the ephemeral nature of containers. Unlike traditional servers that persist for months or years, containers may exist for seconds or minutes. Security practices must be automated and embedded into the build and deployment pipeline rather than applied manually.&lt;/p>
&lt;h2 id="container-image-security">Container Image Security&lt;/h2>
&lt;p>The container image is the foundation of container security. An image that ships with known vulnerabilities, outdated packages, or unnecessary components creates risk before the container even starts.&lt;/p>
&lt;h3 id="base-image-selection">Base Image Selection&lt;/h3>
&lt;p>The choice of base image has an outsized impact on security. A full Linux distribution (like Ubuntu or Debian) may include hundreds of packages that your application never uses but that increase the attack surface. Minimal base images reduce this risk.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Base Image Type&lt;/th>
&lt;th>Packages&lt;/th>
&lt;th>Attack Surface&lt;/th>
&lt;th>Use Case&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Distroless&lt;/strong> (e.g., &lt;code>gcr.io/distroless&lt;/code>)&lt;/td>
&lt;td>Application runtime only&lt;/td>
&lt;td>Minimal&lt;/td>
&lt;td>Production workloads&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;a href="https://www.chainguard.dev/chainguard-images">Chainguard Images&lt;/a>&lt;/strong>&lt;/td>
&lt;td>Minimal, zero/low-CVE packages&lt;/td>
&lt;td>Minimal&lt;/td>
&lt;td>Production workloads, compliance-sensitive environments&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;a href="https://www.docker.com/products/hardened-images/">Docker Hardened Images&lt;/a>&lt;/strong>&lt;/td>
&lt;td>Distroless Debian/Alpine, non-root&lt;/td>
&lt;td>Minimal&lt;/td>
&lt;td>Production workloads, regulated environments&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Alpine Linux&lt;/strong>&lt;/td>
&lt;td>~15 MB base, musl libc&lt;/td>
&lt;td>Small&lt;/td>
&lt;td>General purpose, size-sensitive&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Slim variants&lt;/strong> (e.g., &lt;code>python:3.12-slim&lt;/code>)&lt;/td>
&lt;td>Stripped-down distribution&lt;/td>
&lt;td>Medium&lt;/td>
&lt;td>Language-specific applications&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Full distribution&lt;/strong> (e.g., &lt;code>ubuntu:24.04&lt;/code>)&lt;/td>
&lt;td>Full package set&lt;/td>
&lt;td>Large&lt;/td>
&lt;td>Development, debugging&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>For production, prefer hardened, distroless, or slim images. Fewer packages means fewer potential vulnerabilities and a smaller SBOM — making both security management and compliance simpler.&lt;/p>
&lt;p>Two hardened image providers stand out for security-conscious teams:&lt;/p>
&lt;p>&lt;a href="https://www.chainguard.dev/chainguard-images">Chainguard Images&lt;/a> are built from the ground up on &lt;a href="https://github.com/wolfi-dev">Wolfi&lt;/a>, a Linux distribution designed specifically for containers. They are rebuilt daily, ship with zero or near-zero known CVEs, and include high-quality SBOMs out of the box. Available as drop-in replacements for popular base images like Python, Node.js, and Go.&lt;/p>
&lt;p>&lt;a href="https://www.docker.com/products/hardened-images/">Docker Hardened Images&lt;/a> (DHI) take a different approach — hardening familiar Debian and Alpine bases by stripping them down to distroless principles (no shell, no package manager, non-root by default). Docker &lt;a href="https://www.docker.com/blog/docker-hardened-images-for-every-developer/">made the full catalog of 1,000+ images free and open source&lt;/a> under Apache 2.0 in late 2025. Every image ships with an SBOM, &lt;a href="https://slsa.dev/">SLSA&lt;/a> Build Level 3 provenance, and &lt;a href="https://www.cisa.gov/resources-tools/resources/minimum-requirements-vulnerability-exploitability-exchange-vex">VEX&lt;/a> metadata. The Enterprise tier adds FIPS-enabled and STIG-hardened variants for regulated environments.&lt;/p>
&lt;h3 id="image-scanning">Image Scanning&lt;/h3>
&lt;p>Container image scanning analyzes the contents of an image for known vulnerabilities by matching installed packages and libraries against vulnerability databases like the &lt;a href="https://nvd.nist.gov/">NVD&lt;/a> and &lt;a href="https://osv.dev/">OSV&lt;/a>.&lt;/p>
&lt;p>Key scanning tools include:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://github.com/aquasecurity/trivy">Trivy&lt;/a>&lt;/strong> — Open source scanner from Aqua that detects vulnerabilities in OS packages, language-specific dependencies, and misconfigurations&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://github.com/anchore/grype">Grype&lt;/a>&lt;/strong> — Open source vulnerability scanner from Anchore&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://snyk.io/product/container-vulnerability-management/">Snyk Container&lt;/a>&lt;/strong> — Commercial scanner with developer workflow integration&lt;/li>
&lt;/ul>
&lt;p>Scanning should happen at multiple points: during the CI/CD build, before images are pushed to a registry, and continuously against images already in production (since new vulnerabilities are disclosed daily).&lt;/p>
&lt;h3 id="container-sboms-separate-layers-separate-sboms">Container SBOMs: Separate Layers, Separate SBOMs&lt;/h3>
&lt;p>A containerized application has two distinct layers with different component profiles: the &lt;strong>base image layer&lt;/strong> (OS packages, system libraries) and the &lt;strong>application layer&lt;/strong> (your code&amp;rsquo;s dependencies from lock files). Rather than combining everything into a single monolithic SBOM, the best practice is to generate &lt;strong>separate SBOMs for each layer&lt;/strong> and organize them hierarchically.&lt;/p>
&lt;p>This separation matters for several reasons:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Different update cadences.&lt;/strong> Base image packages change when you rebuild with a new base image; application dependencies change when you update your lock file. Separate SBOMs let you track each independently.&lt;/li>
&lt;li>&lt;strong>Different vulnerability profiles.&lt;/strong> A glibc vulnerability in the base image is a different remediation path than a vulnerability in an npm package. Separate SBOMs make triage clearer.&lt;/li>
&lt;li>&lt;strong>Cleaner compliance.&lt;/strong> Compliance reviewers can evaluate OS-level and application-level components independently, with the correct tool and context for each.&lt;/li>
&lt;/ul>
&lt;p>The &lt;a href="https://github.com/sbomify/github-action/">sbomify GitHub Action&lt;/a> supports this workflow directly — generate an Application SBOM from your lock file and a Container SBOM from the built image, then organize both under a single product using sbomify&amp;rsquo;s &lt;a href="https://sbomify.com/features/sbom-hierarchy/">Product → Project → Component hierarchy&lt;/a>. For step-by-step instructions, see our &lt;a href="https://sbomify.com/guides/docker/">Docker SBOM guide&lt;/a>.&lt;/p>
&lt;h2 id="runtime-security">Runtime Security&lt;/h2>
&lt;p>Image scanning catches known vulnerabilities before deployment, but runtime security protects against exploitation of unknown flaws, misconfigurations, and malicious behavior during execution.&lt;/p>
&lt;h3 id="principle-of-least-privilege">Principle of Least Privilege&lt;/h3>
&lt;p>Containers should run with the minimum permissions required:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Run as non-root.&lt;/strong> The default user in many container images is root. Always specify a non-root user in your Dockerfile (&lt;code>USER nonroot&lt;/code>) or enforce this via Kubernetes security contexts.&lt;/li>
&lt;li>&lt;strong>Drop capabilities.&lt;/strong> Linux capabilities grant fine-grained privileges. Drop all capabilities and add back only those required (&lt;code>--cap-drop=ALL --cap-add=NET_BIND_SERVICE&lt;/code>).&lt;/li>
&lt;li>&lt;strong>Read-only filesystem.&lt;/strong> Mount the container filesystem as read-only where possible (&lt;code>--read-only&lt;/code>), using tmpfs mounts for directories that require writes.&lt;/li>
&lt;li>&lt;strong>No privilege escalation.&lt;/strong> Set &lt;code>allowPrivilegeEscalation: false&lt;/code> in Kubernetes security contexts to prevent processes from gaining additional privileges.&lt;/li>
&lt;/ul>
&lt;h3 id="secrets-management">Secrets Management&lt;/h3>
&lt;p>Never bake secrets (API keys, database credentials, certificates) into container images. Images are stored in registries and can be inspected by anyone with access. Instead:&lt;/p>
&lt;ul>
&lt;li>Use Kubernetes Secrets or a dedicated secrets manager (HashiCorp Vault, AWS Secrets Manager)&lt;/li>
&lt;li>Mount secrets as files or environment variables at runtime&lt;/li>
&lt;li>Rotate secrets regularly and audit access&lt;/li>
&lt;/ul>
&lt;h3 id="runtime-monitoring">Runtime Monitoring&lt;/h3>
&lt;p>Runtime security tools observe container behavior and detect anomalies:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Unexpected processes&lt;/strong> — A web server container suddenly running a shell may indicate compromise&lt;/li>
&lt;li>&lt;strong>Unusual network connections&lt;/strong> — Outbound connections to unknown IP addresses&lt;/li>
&lt;li>&lt;strong>File system modifications&lt;/strong> — Changes to binaries or configuration files in a read-only container&lt;/li>
&lt;li>&lt;strong>Privilege escalation attempts&lt;/strong> — Attempts to gain root access&lt;/li>
&lt;/ul>
&lt;h2 id="kubernetes-security">Kubernetes Security&lt;/h2>
&lt;p>For organizations running containers at scale, Kubernetes introduces its own security considerations.&lt;/p>
&lt;h3 id="network-policies">Network Policies&lt;/h3>
&lt;p>By default, Kubernetes allows all pod-to-pod communication within a cluster. Network policies restrict this to only the connections that are necessary:&lt;/p>
&lt;ul>
&lt;li>Isolate namespaces so that development and production workloads cannot communicate&lt;/li>
&lt;li>Restrict ingress to only the pods that need to receive traffic&lt;/li>
&lt;li>Restrict egress to only the external services that pods need to reach&lt;/li>
&lt;/ul>
&lt;h3 id="pod-security-standards">Pod Security Standards&lt;/h3>
&lt;p>Kubernetes &lt;a href="https://kubernetes.io/docs/concepts/security/pod-security-standards/">Pod Security Standards&lt;/a> define three levels of restriction:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Privileged&lt;/strong> — Unrestricted (use only when necessary)&lt;/li>
&lt;li>&lt;strong>Baseline&lt;/strong> — Prevents known privilege escalations&lt;/li>
&lt;li>&lt;strong>Restricted&lt;/strong> — Hardened configuration following security best practices&lt;/li>
&lt;/ul>
&lt;p>Enforce at least the Baseline level for all production workloads. Use the Restricted level where possible.&lt;/p>
&lt;h3 id="supply-chain-security-for-images">Supply Chain Security for Images&lt;/h3>
&lt;p>Ensure that only trusted, scanned images run in your cluster:&lt;/p>
&lt;ul>
&lt;li>Use a private container registry with access controls&lt;/li>
&lt;li>Sign images and verify signatures before deployment (using tools like &lt;a href="https://docs.sigstore.dev/cosign/">Sigstore cosign&lt;/a>)&lt;/li>
&lt;li>Implement admission controllers that reject unsigned or unscanned images&lt;/li>
&lt;li>Pin images to specific digests rather than mutable tags (&lt;code>:latest&lt;/code> can change without notice)&lt;/li>
&lt;li>Consider using hardened base images from &lt;a href="https://www.chainguard.dev/chainguard-images">Chainguard&lt;/a> or &lt;a href="https://www.docker.com/products/hardened-images/">Docker Hardened Images&lt;/a> that ship with built-in SBOMs, provenance attestations, and near-zero CVEs&lt;/li>
&lt;/ul>
&lt;h2 id="container-security-and-sboms">Container Security and SBOMs&lt;/h2>
&lt;p>SBOMs play a central role in container security by providing the component visibility needed for effective vulnerability management.&lt;/p>
&lt;h3 id="why-separate-container-sboms-matter">Why Separate Container SBOMs Matter&lt;/h3>
&lt;p>A typical container image may contain hundreds of packages across multiple layers. Without SBOMs, identifying whether a newly disclosed vulnerability affects your containers requires manual investigation of each image — a process that does not scale.&lt;/p>
&lt;p>With separate SBOMs for each container layer, organized in a &lt;a href="https://sbomify.com/features/sbom-hierarchy/">hierarchical structure&lt;/a>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://sbomify.com/2026/02/01/sbom-scanning-vulnerability-detection/">Vulnerability scanning&lt;/a> becomes targeted.&lt;/strong> Match base image SBOMs against OS-level advisories and application SBOMs against language-specific vulnerability databases (&lt;a href="https://nvd.nist.gov/">NVD&lt;/a>, &lt;a href="https://osv.dev/">OSV&lt;/a>, &lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA KEV catalog&lt;/a>).&lt;/li>
&lt;li>&lt;strong>Incident response accelerates.&lt;/strong> When a new critical &lt;a href="https://sbomify.com/2025/12/18/cve-vulnerability-explained/">CVE&lt;/a> is disclosed, query your SBOM repository to immediately identify affected images — and know whether the vulnerability is in the base image or your application dependencies.&lt;/li>
&lt;li>&lt;strong>Compliance requirements are met.&lt;/strong> The &lt;a href="https://sbomify.com/compliance/eu-cra/">EU CRA&lt;/a> and &lt;a href="https://sbomify.com/compliance/eo-14028/">EO 14028&lt;/a> require component documentation for software products, including containerized applications.&lt;/li>
&lt;li>&lt;strong>Base image risk is visible.&lt;/strong> Container SBOMs expose the &lt;a href="https://sbomify.com/2026/01/29/what-is-a-dependency-in-software/">dependency&lt;/a> chain inherited from base images that developers may not be aware of, kept separate from application-level components for clarity.&lt;/li>
&lt;/ul>
&lt;p>For detailed instructions on generating separate SBOMs from container images, see our &lt;a href="https://sbomify.com/guides/docker/">Docker SBOM guide&lt;/a>. For a broader overview of SBOM tools, see our &lt;a href="https://sbomify.com/resources/">resources page&lt;/a>.&lt;/p>
&lt;h2 id="best-practices">Best Practices&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Scan images at every stage.&lt;/strong> Integrate scanning into CI/CD (build-time), the container registry (push-time), and production (runtime). New vulnerabilities are disclosed daily — a clean image today may be vulnerable tomorrow.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Use hardened or minimal base images.&lt;/strong> Choose hardened images (&lt;a href="https://www.chainguard.dev/chainguard-images">Chainguard&lt;/a>, &lt;a href="https://www.docker.com/products/hardened-images/">Docker Hardened Images&lt;/a>), distroless, or slim variants for production. Fewer packages means fewer vulnerabilities and a smaller attack surface.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Generate separate SBOMs per layer.&lt;/strong> Generate an application SBOM from your lock file and a container SBOM from the built image. Organize both under a single product in your &lt;a href="https://sbomify.com/2026/01/18/sbom-management-best-practices/">SBOM management platform&lt;/a> for continuous vulnerability monitoring.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Run containers as non-root.&lt;/strong> Never run production containers as the root user. Configure security contexts to drop unnecessary capabilities and prevent privilege escalation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Implement network policies.&lt;/strong> Do not rely on default allow-all networking. Define explicit network policies that restrict communication to only what is required.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Sign and verify images.&lt;/strong> Use image signing to establish provenance and prevent deployment of tampered images. Verify signatures with admission controllers in Kubernetes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Keep base images up to date.&lt;/strong> Regularly rebuild images with updated base layers to pick up security patches. Automate this with scheduled rebuilds in your CI/CD pipeline.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Manage secrets properly.&lt;/strong> Never embed secrets in images. Use dedicated secrets management tools and mount secrets at runtime.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="frequently-asked-questions">Frequently Asked Questions&lt;/h2>
&lt;h3 id="what-is-container-security-1">What is container security?&lt;/h3>
&lt;p>Container security is the practice of protecting containerized applications and their infrastructure throughout the lifecycle — from building images through deployment and runtime operations. It encompasses image scanning, vulnerability management, runtime protection, network policies, secrets management, and access control for container orchestration platforms like Kubernetes.&lt;/p>
&lt;h3 id="how-do-you-scan-container-images-for-vulnerabilities">How do you scan container images for vulnerabilities?&lt;/h3>
&lt;p>Container images are scanned by analyzing their contents (OS packages, language libraries, application dependencies) against vulnerability databases like the NVD and OSV. Tools like Trivy, Grype, and Snyk perform this analysis. Scanning should be integrated into CI/CD pipelines, container registries, and production monitoring to catch vulnerabilities at every stage.&lt;/p>
&lt;h3 id="what-is-a-container-sbom">What is a container SBOM?&lt;/h3>
&lt;p>A container SBOM is a Software Bill of Materials generated from a built container image, documenting the OS-level packages and system libraries in the base image. Best practice is to generate this separately from your application SBOM (which covers your code&amp;rsquo;s dependencies from lock files) and organize both under a product hierarchy. This separation keeps vulnerability triage and compliance clear. See our &lt;a href="https://sbomify.com/guides/docker/">Docker SBOM guide&lt;/a> for detailed instructions on generating separate SBOMs for each layer.&lt;/p>
&lt;h3 id="how-does-kubernetes-improve-container-security">How does Kubernetes improve container security?&lt;/h3>
&lt;p>Kubernetes provides security mechanisms including Pod Security Standards (restricting container privileges), Network Policies (controlling pod-to-pod communication), RBAC (role-based access control), Secrets management, and admission controllers (enforcing policies on what can be deployed). These features must be actively configured — Kubernetes defaults are permissive.&lt;/p>
&lt;h3 id="why-should-containers-run-as-non-root">Why should containers run as non-root?&lt;/h3>
&lt;p>Running containers as root means that a compromise of the application gives the attacker root privileges inside the container, which in some configurations can lead to host escape. Running as a non-root user limits the blast radius of a compromise. Combined with dropping capabilities and setting &lt;code>allowPrivilegeEscalation: false&lt;/code>, non-root containers significantly reduce risk.&lt;/p></description><category>education</category></item><item><title>What Is a KEV? Understanding CISA&amp;#39;s Known Exploited Vulnerabilities Catalog</title><link>https://sbomify.com/2025/12/30/what-is-kev-cisa-known-exploited-vulnerabilities/</link><pubDate>Tue, 30 Dec 2025 00:00:00 +0000</pubDate><guid>https://sbomify.com/2025/12/30/what-is-kev-cisa-known-exploited-vulnerabilities/</guid><description>&lt;p>A KEV (Known Exploited Vulnerability) is a vulnerability that has been confirmed as actively exploited in the wild. The &lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA Known Exploited Vulnerabilities Catalog&lt;/a>, maintained by the Cybersecurity and Infrastructure Security Agency, is the authoritative list of these vulnerabilities. Unlike CVE databases that catalog all publicly known flaws, or CVSS scores that estimate theoretical severity, the KEV catalog answers a more urgent question: &lt;em>is this vulnerability being exploited right now?&lt;/em>&lt;/p>
&lt;p>&lt;img src="https://sbomify.com/assets/images/d2/vulnerability-prioritization.svg" alt="Vulnerability prioritization flow from CVE through CVSS and KEV to SBOM-based remediation">&lt;/p>
&lt;h2 id="what-is-the-kev-catalog">What Is the KEV Catalog?&lt;/h2>
&lt;p>The CISA KEV catalog is a curated list of &lt;a href="https://sbomify.com/2025/12/18/cve-vulnerability-explained/">CVE&lt;/a> vulnerabilities that have reliable evidence of active exploitation. CISA launched the catalog in November 2021 alongside &lt;a href="https://www.cisa.gov/news-events/directives/bod-22-01-reducing-significant-risk-known-exploited-vulnerabilities">Binding Operational Directive (BOD) 22-01&lt;/a>, which requires U.S. federal civilian executive branch (FCEB) agencies to remediate KEV-listed vulnerabilities within specified timeframes.&lt;/p>
&lt;p>As of early 2026, the KEV catalog contains nearly 1,500 entries. New vulnerabilities are added as CISA confirms evidence of exploitation, and each entry includes:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>CVE ID&lt;/strong> identifying the vulnerability&lt;/li>
&lt;li>&lt;strong>Vendor and product&lt;/strong> affected&lt;/li>
&lt;li>&lt;strong>Vulnerability name&lt;/strong> and description&lt;/li>
&lt;li>&lt;strong>Date added&lt;/strong> to the catalog&lt;/li>
&lt;li>&lt;strong>Due date&lt;/strong> for federal agency remediation&lt;/li>
&lt;li>&lt;strong>Required action&lt;/strong> (typically &amp;ldquo;Apply updates per vendor instructions&amp;rdquo;)&lt;/li>
&lt;li>&lt;strong>Known ransomware campaign use&lt;/strong> (yes/no flag)&lt;/li>
&lt;/ul>
&lt;p>The catalog is freely available as a &lt;a href="https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json">JSON feed&lt;/a>, a &lt;a href="https://www.cisa.gov/sites/default/files/csv/known_exploited_vulnerabilities.csv">CSV download&lt;/a>, and through the CISA website.&lt;/p>
&lt;h2 id="kev-vs-cve-vs-cvss-how-they-work-together">KEV vs. CVE vs. CVSS: How They Work Together&lt;/h2>
&lt;p>These three systems are complementary, not competing. Each answers a different question in the vulnerability management process.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>System&lt;/th>
&lt;th>Question It Answers&lt;/th>
&lt;th>Maintained By&lt;/th>
&lt;th>Output&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>CVE&lt;/strong>&lt;/td>
&lt;td>What is this vulnerability?&lt;/td>
&lt;td>&lt;a href="https://www.cve.org/">MITRE Corporation&lt;/a>&lt;/td>
&lt;td>Unique identifier (e.g., CVE-2021-44228)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>CVSS&lt;/strong>&lt;/td>
&lt;td>How severe is this vulnerability?&lt;/td>
&lt;td>&lt;a href="https://www.first.org/cvss/">FIRST.org&lt;/a>&lt;/td>
&lt;td>Severity score (0.0-10.0)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>KEV&lt;/strong>&lt;/td>
&lt;td>Is this vulnerability being exploited?&lt;/td>
&lt;td>&lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA&lt;/a>&lt;/td>
&lt;td>Binary yes/no (listed or not)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>A CVE tells you a vulnerability exists. CVSS tells you how bad it &lt;em>could&lt;/em> be. KEV tells you it &lt;em>is&lt;/em> being exploited. Effective vulnerability prioritization uses all three signals together.&lt;/p>
&lt;p>Consider two vulnerabilities, both with CVSS scores of 9.8 (Critical). One is listed in the KEV catalog; the other is not. The KEV-listed vulnerability should be patched first because there is confirmed evidence that attackers are actively exploiting it, whereas the other, while theoretically severe, may not have working exploits in circulation.&lt;/p>
&lt;h2 id="binding-operational-directive-22-01">Binding Operational Directive 22-01&lt;/h2>
&lt;p>&lt;a href="https://www.cisa.gov/news-events/directives/bod-22-01-reducing-significant-risk-known-exploited-vulnerabilities">BOD 22-01&lt;/a> (&amp;ldquo;Reducing the Significant Risk of Known Exploited Vulnerabilities&amp;rdquo;) is the CISA directive that established the KEV catalog&amp;rsquo;s operational role. It requires FCEB agencies to:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Review&lt;/strong> the KEV catalog on an ongoing basis&lt;/li>
&lt;li>&lt;strong>Remediate&lt;/strong> each KEV vulnerability by the due date specified in the catalog&lt;/li>
&lt;li>&lt;strong>Report&lt;/strong> their remediation status to CISA&lt;/li>
&lt;/ol>
&lt;p>While BOD 22-01 only legally binds federal civilian agencies, CISA strongly recommends that all organizations — including state and local governments, critical infrastructure operators, and private sector companies — use the KEV catalog as a prioritization input for their vulnerability management programs.&lt;/p>
&lt;p>The remediation timelines in BOD 22-01 are aggressive. Newly added KEVs typically have due dates of two to three weeks from the date of addition. This reflects the urgency: if a vulnerability is being actively exploited, delayed patching means continued exposure.&lt;/p>
&lt;h2 id="how-the-kev-catalog-is-maintained">How the KEV Catalog Is Maintained&lt;/h2>
&lt;p>CISA adds vulnerabilities to the KEV catalog based on three criteria, all of which must be met:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>The vulnerability has an assigned CVE ID.&lt;/strong> Only cataloged vulnerabilities with standard identifiers qualify.&lt;/li>
&lt;li>&lt;strong>There is reliable evidence of active exploitation.&lt;/strong> This evidence may come from CISA&amp;rsquo;s own threat intelligence, reports from federal agencies, industry partners, or trusted cybersecurity organizations.&lt;/li>
&lt;li>&lt;strong>A clear remediation action exists.&lt;/strong> Typically this means a vendor patch or mitigation is available. CISA does not add vulnerabilities for which there is no known fix, as doing so would disclose exploited flaws without offering a path to resolution.&lt;/li>
&lt;/ol>
&lt;p>Vulnerabilities are rarely removed from the KEV catalog once added — even after the remediation deadline passes. While CISA has removed entries in rare cases where evidence of exploitation was later found insufficient, the catalog serves primarily as a persistent historical record of exploitation activity.&lt;/p>
&lt;h2 id="using-the-kev-catalog-for-patch-prioritization">Using the KEV Catalog for Patch Prioritization&lt;/h2>
&lt;p>Most organizations face far more vulnerabilities than they can patch simultaneously. The KEV catalog provides a practical prioritization signal that cuts through the noise.&lt;/p>
&lt;h3 id="a-prioritization-framework">A Prioritization Framework&lt;/h3>
&lt;p>A common approach combines CVSS severity with KEV status and deployment context:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Critical + KEV-listed + Internet-facing&lt;/strong> — Patch immediately (within 24-48 hours)&lt;/li>
&lt;li>&lt;strong>Critical + KEV-listed + Internal&lt;/strong> — Patch within the BOD 22-01 deadline (typically 2-3 weeks)&lt;/li>
&lt;li>&lt;strong>Critical + Not KEV-listed&lt;/strong> — Patch within standard SLA (typically 30 days)&lt;/li>
&lt;li>&lt;strong>High + KEV-listed&lt;/strong> — Treat as critical; patch within 2-3 weeks&lt;/li>
&lt;li>&lt;strong>High + Not KEV-listed&lt;/strong> — Patch within standard SLA&lt;/li>
&lt;li>&lt;strong>Medium/Low + Not KEV-listed&lt;/strong> — Schedule for regular maintenance windows&lt;/li>
&lt;/ol>
&lt;p>This framework is a starting point. Organizations should adjust based on their risk tolerance, asset criticality, and compensating controls.&lt;/p>
&lt;h3 id="the-ransomware-flag">The Ransomware Flag&lt;/h3>
&lt;p>Since October 2023, CISA has included a &amp;ldquo;Known Ransomware Campaign Use&amp;rdquo; flag in KEV entries, as part of its Ransomware Vulnerability Warning Pilot (RVWP). This binary indicator (yes/no) signals whether the vulnerability has been used in ransomware operations. Vulnerabilities flagged for ransomware use warrant heightened urgency due to the potential for data encryption and operational disruption.&lt;/p>
&lt;h2 id="kev-and-sboms-automated-monitoring">KEV and SBOMs: Automated Monitoring&lt;/h2>
&lt;p>The real power of the KEV catalog emerges when combined with &lt;a href="https://sbomify.com/what-is-sbom/">SBOMs&lt;/a>. An SBOM provides a machine-readable inventory of every component in your software. The KEV catalog provides a machine-readable list of actively exploited vulnerabilities. Connecting the two creates automated, continuous monitoring.&lt;/p>
&lt;h3 id="how-it-works">How It Works&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>Generate SBOMs&lt;/strong> for all your applications using tools from our &lt;a href="https://sbomify.com/guides/">SBOM generation guides&lt;/a>&lt;/li>
&lt;li>&lt;strong>Ingest SBOMs&lt;/strong> into a management platform such as &lt;a href="https://sbomify.com">sbomify&lt;/a> or &lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a>&lt;/li>
&lt;li>&lt;strong>Run vulnerability analysis&lt;/strong> — tools like Google OSV and Dependency-Track identify known CVEs in your SBOM components&lt;/li>
&lt;li>&lt;strong>Cross-reference with KEV&lt;/strong> — check which of those CVEs appear in the KEV catalog to identify actively exploited vulnerabilities&lt;/li>
&lt;li>&lt;strong>Prioritize remediation&lt;/strong> using the KEV due date and your deployment context&lt;/li>
&lt;/ol>
&lt;p>Because CISA adds new KEVs multiple times per week, building this cross-referencing into your workflow is important. The KEV catalog&amp;rsquo;s machine-readable formats make this feasible to automate.&lt;/p>
&lt;h3 id="integration-points">Integration Points&lt;/h3>
&lt;p>Several tools and data sources support KEV-SBOM workflows:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json">CISA KEV JSON feed&lt;/a>&lt;/strong> — Machine-readable, updated as new KEVs are added&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://sbomify.com">sbomify&lt;/a>&lt;/strong> — SBOM management platform with vulnerability analysis via Google OSV integration&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a>&lt;/strong> — Ingests SBOMs and performs vulnerability analysis using multiple data sources&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://github.com/anchore/grype">Grype&lt;/a>&lt;/strong> — Command-line vulnerability scanner that can match against vulnerability data&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://osv.dev/">OSV&lt;/a>&lt;/strong> — Google&amp;rsquo;s open source vulnerability database&lt;/li>
&lt;/ul>
&lt;p>For a comprehensive list of analysis tools, see our &lt;a href="https://sbomify.com/resources/">SBOM resources page&lt;/a>.&lt;/p>
&lt;h2 id="kev-in-the-compliance-context">KEV in the Compliance Context&lt;/h2>
&lt;p>The KEV catalog intersects with several compliance frameworks:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://sbomify.com/compliance/eo-14028/">Executive Order 14028&lt;/a>&lt;/strong> directs agencies to improve vulnerability management, and KEV provides the prioritization mechanism.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://sbomify.com/compliance/cisa-minimum-elements/">CISA minimum elements&lt;/a>&lt;/strong> recommend unique identifiers (like purl or CPE) in SBOMs, enabling automated matching against KEV entries.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://sbomify.com/compliance/nist-800-53/">NIST SP 800-53&lt;/a> SI-5&lt;/strong> requires receiving and acting on security alerts and advisories — the KEV catalog is a primary source for this control.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://sbomify.com/compliance/eu-cra/">EU CRA&lt;/a>&lt;/strong> requires vulnerability handling processes, and KEV status is a valuable input for prioritizing which vulnerabilities to address first.&lt;/li>
&lt;/ul>
&lt;h2 id="frequently-asked-questions">Frequently Asked Questions&lt;/h2>
&lt;h3 id="what-is-a-kev">What is a KEV?&lt;/h3>
&lt;p>A KEV (Known Exploited Vulnerability) is a CVE vulnerability that CISA has confirmed is being actively exploited in real-world attacks. The CISA KEV catalog lists these vulnerabilities along with remediation deadlines and required actions. Being listed in the KEV catalog means the vulnerability is not just theoretically dangerous — it is being used by attackers right now.&lt;/p>
&lt;h3 id="what-is-the-kev-catalog-1">What is the KEV catalog?&lt;/h3>
&lt;p>The CISA Known Exploited Vulnerabilities Catalog is a curated, continuously updated list of CVE vulnerabilities with confirmed active exploitation. Established by Binding Operational Directive 22-01, it requires U.S. federal agencies to remediate listed vulnerabilities within specified timeframes. The catalog is freely available as JSON, CSV, and via the CISA website, and is widely used by both government and private sector organizations for patch prioritization.&lt;/p>
&lt;h3 id="how-is-kev-different-from-cve">How is KEV different from CVE?&lt;/h3>
&lt;p>CVE is a system for assigning unique identifiers to all publicly known vulnerabilities, regardless of whether they are being exploited. The KEV catalog is a curated subset of CVEs that have confirmed evidence of active exploitation. There are over 330,000 CVE entries but only about 1,500 KEV entries. A CVE tells you a vulnerability exists; a KEV listing tells you attackers are actively using it.&lt;/p>
&lt;h3 id="who-must-comply-with-the-kev-catalog">Who must comply with the KEV catalog?&lt;/h3>
&lt;p>BOD 22-01 legally requires U.S. federal civilian executive branch (FCEB) agencies to remediate KEV-listed vulnerabilities by the specified due dates. However, CISA strongly recommends that all organizations use the KEV catalog for prioritization. Many private sector organizations, state and local governments, and critical infrastructure operators have adopted KEV as a standard input to their vulnerability management programs.&lt;/p>
&lt;h3 id="how-can-i-monitor-the-kev-catalog-automatically">How can I monitor the KEV catalog automatically?&lt;/h3>
&lt;p>Generate SBOMs for your applications, ingest them into a vulnerability management platform like OWASP Dependency-Track, and use vulnerability analysis to identify known CVEs in your components. Then cross-reference those CVEs against the KEV catalog. CISA publishes the KEV catalog as a machine-readable &lt;a href="https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json">JSON feed&lt;/a> that can be consumed by automated tools.&lt;/p></description><category>education</category></item><item><title>Software Supply Chain Management: Risks, Best Practices, and SBOM Integration</title><link>https://sbomify.com/2025/12/26/software-supply-chain-management/</link><pubDate>Fri, 26 Dec 2025 00:00:00 +0000</pubDate><guid>https://sbomify.com/2025/12/26/software-supply-chain-management/</guid><description>&lt;p>Software supply chain management is the practice of identifying, assessing, and mitigating risks across the entire chain of components, tools, and processes used to develop and deliver software. A software supply chain encompasses everything that contributes to a finished application: open source libraries, third-party services, build tools, package registries, CI/CD pipelines, and the people and processes that connect them. Managing this chain is essential because a vulnerability or compromise at any point can propagate downstream to every consumer of the software.&lt;/p>
&lt;p>&lt;img src="https://sbomify.com/assets/images/d2/supply-chain-risk.svg" alt="Software supply chain from upstream dependencies through build to downstream consumers">&lt;/p>
&lt;h2 id="what-is-a-software-supply-chain">What Is a Software Supply Chain?&lt;/h2>
&lt;p>A software supply chain is the complete set of components, dependencies, tools, and workflows involved in creating, building, and distributing a piece of software. Just as a physical supply chain traces the path of raw materials through manufacturing to a finished product, a software supply chain traces the path of code from its origins to its deployment.&lt;/p>
&lt;p>Modern applications are overwhelmingly assembled rather than written from scratch. Studies consistently show that &lt;a href="https://www.linux.com/training-tutorials/estimating-total-number-linux-contributors-approach-using-linus-law/">70-90% of a typical application consists of open source components&lt;/a> drawn from public package registries like npm, PyPI, Maven Central, and crates.io. Each of these components has its own dependencies, creating a deep tree of transitive dependencies that most development teams never manually audit.&lt;/p>
&lt;p>This reality makes software supply chain risk management (SSCRM) a critical discipline. If a single component in your dependency tree is compromised, vulnerable, or abandoned, the risk flows directly into your application and to your users.&lt;/p>
&lt;h2 id="chain-of-custody-in-software">Chain of Custody in Software&lt;/h2>
&lt;p>Chain of custody is a concept borrowed from forensics and physical supply chains. In the software context, chain of custody refers to the documented trail that records who created, modified, built, and distributed each component in a software product. A robust chain of custody answers questions like:&lt;/p>
&lt;ul>
&lt;li>Where did this component originate?&lt;/li>
&lt;li>Who authored and maintained it?&lt;/li>
&lt;li>Was it modified between the source repository and the package registry?&lt;/li>
&lt;li>Was the build process reproducible and tamper-evident?&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://sbomify.com/what-is-sbom/">Software Bills of Materials&lt;/a> (SBOMs) provide the component-level inventory that underpins chain of custody. Frameworks like &lt;a href="https://sbomify.com/2024/08/17/what-is-slsa/">SLSA&lt;/a> (Supply-chain Levels for Software Artifacts) and &lt;a href="https://in-toto.io/">in-toto&lt;/a> add attestation layers that cryptographically verify each step in the build process.&lt;/p>
&lt;h2 id="major-software-supply-chain-attacks">Major Software Supply Chain Attacks&lt;/h2>
&lt;p>Several high-profile incidents have demonstrated the consequences of supply chain compromise.&lt;/p>
&lt;h3 id="solarwinds-2020">SolarWinds (2020)&lt;/h3>
&lt;p>Attackers compromised the build system of SolarWinds&amp;rsquo; Orion IT monitoring platform, injecting malicious code into a routine software update. Approximately 18,000 organizations, including U.S. government agencies, installed the compromised update. The attack was attributed to a state-sponsored actor and went undetected for months. It demonstrated that compromising a single widely-used vendor can provide access to thousands of downstream organizations.&lt;/p>
&lt;h3 id="log4shell-2021">Log4Shell (2021)&lt;/h3>
&lt;p>&lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-44228">CVE-2021-44228&lt;/a>, known as Log4Shell, was a critical remote code execution vulnerability in Apache Log4j, a ubiquitous Java logging library. The vulnerability affected millions of applications worldwide. Organizations without component inventories struggled for weeks to determine whether they were affected. This incident became the single most cited argument for SBOM adoption: organizations with SBOMs could identify affected systems in minutes.&lt;/p>
&lt;h3 id="xz-utils-backdoor-2024">XZ Utils Backdoor (2024)&lt;/h3>
&lt;p>&lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2024-3094">CVE-2024-3094&lt;/a> revealed a deliberately planted backdoor in the XZ Utils compression library, a component present in virtually every Linux distribution. A malicious contributor spent years building trust in the project before inserting the backdoor. This attack showed that supply chain risks include not just accidental vulnerabilities but intentional sabotage through social engineering of open source maintainers.&lt;/p>
&lt;h3 id="common-attack-vectors">Common Attack Vectors&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Attack Vector&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Example&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Build system compromise&lt;/strong>&lt;/td>
&lt;td>Injecting malicious code during the build/CI process&lt;/td>
&lt;td>SolarWinds&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Dependency confusion&lt;/strong>&lt;/td>
&lt;td>Publishing malicious packages with names that overlap internal packages&lt;/td>
&lt;td>Multiple incidents across npm, PyPI&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Typosquatting&lt;/strong>&lt;/td>
&lt;td>Publishing packages with names similar to popular libraries&lt;/td>
&lt;td>Thousands of examples across registries&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Maintainer compromise&lt;/strong>&lt;/td>
&lt;td>Gaining control of a legitimate package through social engineering&lt;/td>
&lt;td>XZ Utils&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Vulnerable dependency&lt;/strong>&lt;/td>
&lt;td>Exploiting a known vulnerability in a widely-used component&lt;/td>
&lt;td>Log4Shell&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="software-supply-chain-risk-management-frameworks">Software Supply Chain Risk Management Frameworks&lt;/h2>
&lt;p>Several frameworks provide structured approaches to managing software supply chain risk.&lt;/p>
&lt;h3 id="nist-c-scrm-sp-800-161-rev-1">NIST C-SCRM (SP 800-161 Rev 1)&lt;/h3>
&lt;p>&lt;a href="https://csrc.nist.gov/pubs/sp/800/161/r1/final">NIST SP 800-161 Rev 1&lt;/a> (&amp;ldquo;Cybersecurity Supply Chain Risk Management Practices for Systems and Organizations&amp;rdquo;) provides the most comprehensive federal guidance on supply chain risk. It builds on the &lt;a href="https://sbomify.com/compliance/nist-800-53/">NIST SP 800-53&lt;/a> control framework, particularly the SR (Supply Chain Risk Management) family, and provides detailed practices for identifying, assessing, and mitigating supply chain risks throughout the system development life cycle.&lt;/p>
&lt;h3 id="executive-order-14028">Executive Order 14028&lt;/h3>
&lt;p>&lt;a href="https://sbomify.com/compliance/eo-14028/">Executive Order 14028&lt;/a> (&amp;ldquo;Improving the Nation&amp;rsquo;s Cybersecurity&amp;rdquo;, 2021) directed federal agencies to enhance software supply chain security, including requiring SBOMs from software vendors and establishing the &lt;a href="https://sbomify.com/compliance/ntia-minimum-elements/">NTIA minimum elements&lt;/a> for SBOM content.&lt;/p>
&lt;h3 id="eu-cyber-resilience-act">EU Cyber Resilience Act&lt;/h3>
&lt;p>The &lt;a href="https://sbomify.com/compliance/eu-cra/">EU Cyber Resilience Act&lt;/a> (CRA) requires manufacturers of products with digital elements to identify and document vulnerabilities and components, including providing SBOMs. The CRA makes software supply chain transparency a legal obligation for products sold in the EU market.&lt;/p>
&lt;h3 id="slsa-framework">SLSA Framework&lt;/h3>
&lt;p>&lt;a href="https://slsa.dev/">SLSA&lt;/a> (Supply-chain Levels for Software Artifacts) is a framework from the &lt;a href="https://openssf.org/">OpenSSF&lt;/a> that defines three levels of build security maturity in the current &lt;a href="https://slsa.dev/spec/v1.0/levels">v1.0 specification&lt;/a>. Each level adds protections: from documenting build provenance (Level 1) through using a hosted build platform (Level 2) to hardened, tamper-resistant builds (Level 3).&lt;/p>
&lt;h2 id="how-sboms-support-supply-chain-management">How SBOMs Support Supply Chain Management&lt;/h2>
&lt;p>An &lt;a href="https://sbomify.com/what-is-sbom/">SBOM&lt;/a> is the foundational tool for software supply chain visibility. Without knowing what components are in your software, you cannot assess supply chain risk. SBOMs support supply chain management in several ways:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Component visibility.&lt;/strong> SBOMs provide a complete inventory of every library, framework, and module in your application, including transitive dependencies that developers may not be aware of.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Vulnerability identification.&lt;/strong> Once you have an SBOM, platforms like &lt;a href="https://sbomify.com">sbomify&lt;/a> and &lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a> can continuously match your components against vulnerability databases like the &lt;a href="https://nvd.nist.gov/">NVD&lt;/a> and &lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA KEV catalog&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>License compliance.&lt;/strong> SBOMs document the license of each component, enabling automated detection of copyleft or restrictive licenses that may create legal obligations. See our &lt;a href="https://sbomify.com/2025/12/22/gpl-license-guide/">GPL license guide&lt;/a> for details on copyleft compliance.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Incident response.&lt;/strong> When a new vulnerability is disclosed, SBOMs allow you to immediately determine which of your products are affected, drastically reducing response time.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Regulatory compliance.&lt;/strong> Multiple frameworks now require or strongly recommend SBOMs, including &lt;a href="https://sbomify.com/compliance/eo-14028/">EO 14028&lt;/a>, the &lt;a href="https://sbomify.com/compliance/eu-cra/">EU CRA&lt;/a>, and &lt;a href="https://sbomify.com/compliance/fda-medical-device/">FDA medical device guidance&lt;/a>. See our &lt;a href="https://sbomify.com/compliance/">compliance guide&lt;/a> for a complete comparison.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>To start generating SBOMs for your projects, see our &lt;a href="https://sbomify.com/guides/">language-specific SBOM guides&lt;/a> covering Python, JavaScript, Java, Go, Rust, and more.&lt;/p>
&lt;h2 id="best-practices-for-software-supply-chain-security">Best Practices for Software Supply Chain Security&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Generate and maintain SBOMs.&lt;/strong> Automate SBOM generation in your CI/CD pipeline using tools like the &lt;a href="https://github.com/sbomify/github-action/">sbomify GitHub Action&lt;/a>. Keep SBOMs current with every release.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Monitor dependencies continuously.&lt;/strong> Do not rely on point-in-time audits. Use SBOM-based monitoring to catch newly disclosed vulnerabilities in your deployed components.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Verify component provenance.&lt;/strong> Use signed packages, verify checksums, and adopt frameworks like SLSA to ensure components have not been tampered with between source and deployment.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Minimize your dependency footprint.&lt;/strong> Fewer dependencies mean a smaller attack surface. Regularly review and remove unused dependencies. Prefer well-maintained libraries with active security response processes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Pin and lock dependencies.&lt;/strong> Use lock files to ensure reproducible builds and prevent unexpected dependency updates. Review dependency changes before merging.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Establish a vulnerability response process.&lt;/strong> Define SLAs for patching based on severity and exploitability. Monitor the &lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA KEV catalog&lt;/a> for actively exploited vulnerabilities in your stack.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Evaluate suppliers.&lt;/strong> For critical commercial dependencies, assess the vendor&amp;rsquo;s security practices, including whether they provide SBOMs and maintain vulnerability disclosure processes.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="frequently-asked-questions">Frequently Asked Questions&lt;/h2>
&lt;h3 id="what-is-software-supply-chain-management">What is software supply chain management?&lt;/h3>
&lt;p>Software supply chain management is the practice of identifying, assessing, and mitigating risks across the full chain of components, tools, and processes used to build and deliver software. It encompasses open source dependency management, build pipeline security, vendor assessment, and ongoing vulnerability monitoring. The goal is to ensure that every component in your software is known, trusted, and up to date.&lt;/p>
&lt;h3 id="what-is-a-chain-of-custody-in-software">What is a chain of custody in software?&lt;/h3>
&lt;p>Chain of custody in the software context refers to the documented, verifiable record of who created, modified, built, and distributed each component in a software product. It establishes trust by providing evidence that a component has not been tampered with between its source and its deployment. SBOMs, build attestations (like SLSA provenance), and code signing are the primary tools for establishing software chain of custody.&lt;/p>
&lt;h3 id="how-do-sboms-help-with-supply-chain-security">How do SBOMs help with supply chain security?&lt;/h3>
&lt;p>SBOMs provide the component-level visibility that is the foundation of supply chain security. Without knowing what is in your software, you cannot assess risk, identify vulnerabilities, or respond to incidents. SBOMs enable automated vulnerability scanning, license compliance checking, and rapid incident response when new vulnerabilities like Log4Shell are disclosed. They are required or recommended by most major compliance frameworks.&lt;/p>
&lt;h3 id="what-is-the-nist-risk-management-framework-for-supply-chains">What is the NIST risk management framework for supply chains?&lt;/h3>
&lt;p>NIST publishes several frameworks relevant to supply chain risk management. &lt;a href="https://csrc.nist.gov/pubs/sp/800/161/r1/final">NIST SP 800-161 Rev 1&lt;/a> is the primary guidance for cybersecurity supply chain risk management (C-SCRM). &lt;a href="https://sbomify.com/compliance/nist-800-53/">NIST SP 800-53 Rev 5&lt;/a> includes the SR (Supply Chain Risk Management) control family with specific controls for provenance (SR-4) and supply chain processes (SR-3). These frameworks are increasingly referenced in procurement requirements and compliance obligations.&lt;/p>
&lt;h3 id="what-are-the-biggest-software-supply-chain-risks">What are the biggest software supply chain risks?&lt;/h3>
&lt;p>The most significant risks include: vulnerable open source dependencies (the most common attack surface), compromised build systems (as in SolarWinds), malicious packages in public registries (typosquatting and dependency confusion), and social engineering of open source maintainers (as in XZ Utils). Transitive dependencies, which are pulled in indirectly and often unreviewed, represent a particularly underestimated risk.&lt;/p></description><category>education</category></item><item><title>CVE Vulnerabilities Explained: What They Are and Why They Matter</title><link>https://sbomify.com/2025/12/18/cve-vulnerability-explained/</link><pubDate>Thu, 18 Dec 2025 00:00:00 +0000</pubDate><guid>https://sbomify.com/2025/12/18/cve-vulnerability-explained/</guid><description>&lt;p>A CVE (Common Vulnerabilities and Exposures) is a standardized identifier assigned to a publicly known cybersecurity vulnerability. Each CVE entry provides a unique ID, a description, and references to related advisories, giving security teams a common language for tracking and discussing specific flaws. The CVE system is maintained by the &lt;a href="https://www.cve.org/">MITRE Corporation&lt;/a> and serves as the backbone of modern vulnerability management across the software industry.&lt;/p>
&lt;p>&lt;img src="https://sbomify.com/assets/images/d2/cve-lifecycle.svg" alt="CVE lifecycle from discovery through remediation">&lt;/p>
&lt;h2 id="what-is-a-cve">What Is a CVE?&lt;/h2>
&lt;p>CVE stands for Common Vulnerabilities and Exposures. It is a dictionary of publicly disclosed security flaws, each assigned a unique identifier in the format &lt;code>CVE-YEAR-NUMBER&lt;/code> (for example, &lt;code>CVE-2021-44228&lt;/code> for the Log4Shell vulnerability). The CVE system does not rate the severity of vulnerabilities — it simply catalogs them with a standardized reference that anyone in the cybersecurity community can use unambiguously.&lt;/p>
&lt;p>The program was launched in 1999 by MITRE Corporation with funding from the U.S. Department of Homeland Security (DHS) and the Cybersecurity and Infrastructure Security Agency (&lt;a href="https://www.cisa.gov/">CISA&lt;/a>). Before CVE existed, different vendors and databases used their own naming schemes for the same vulnerability, leading to confusion and duplicated effort. CVE solved this by providing a single, authoritative numbering system.&lt;/p>
&lt;p>As of early 2026, the CVE database contains over 330,000 entries and continues to grow rapidly — over 48,000 CVEs were published in 2025 alone. The MITRE CVE program relies on a network of CVE Numbering Authorities (CNAs) — organizations authorized to assign CVE IDs within their scope. Major CNAs include Microsoft, Google, Red Hat, Apache, and hundreds of other vendors and open source projects.&lt;/p>
&lt;h2 id="how-the-cve-process-works">How the CVE Process Works&lt;/h2>
&lt;h3 id="discovery-and-assignment">Discovery and Assignment&lt;/h3>
&lt;p>When a vulnerability is discovered — by a security researcher, vendor, or automated tool — it can be reported to the relevant CNA or directly to MITRE. The CNA evaluates the report and, if it meets the criteria (a security flaw in publicly available software that can be independently fixed), assigns a CVE ID.&lt;/p>
&lt;h3 id="publication">Publication&lt;/h3>
&lt;p>Once assigned, the CVE entry is published to the &lt;a href="https://www.cve.org/">CVE List&lt;/a> with a description and references. The entry may initially be marked as &amp;ldquo;reserved&amp;rdquo; while the vendor works on a patch, then updated with full details upon coordinated public disclosure.&lt;/p>
&lt;h3 id="enrichment">Enrichment&lt;/h3>
&lt;p>After publication, the &lt;a href="https://nvd.nist.gov/">National Vulnerability Database&lt;/a> (NVD), maintained by NIST, enriches the CVE with additional data: severity scores (via CVSS), affected product configurations (CPE data), and references to patches and advisories. This enrichment makes CVE data actionable for vulnerability management tools.&lt;/p>
&lt;h2 id="cve-vs-cvss-vs-kev-understanding-the-differences">CVE vs. CVSS vs. KEV: Understanding the Differences&lt;/h2>
&lt;p>These three acronyms are related but distinct. Confusing them is common, so here is a clear breakdown.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Term&lt;/th>
&lt;th>What It Is&lt;/th>
&lt;th>Who Maintains It&lt;/th>
&lt;th>Purpose&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>CVE&lt;/strong>&lt;/td>
&lt;td>Unique vulnerability identifier&lt;/td>
&lt;td>MITRE Corporation&lt;/td>
&lt;td>Catalog and name individual vulnerabilities&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>CVSS&lt;/strong>&lt;/td>
&lt;td>Severity scoring system (0.0–10.0)&lt;/td>
&lt;td>&lt;a href="https://www.first.org/cvss/">FIRST.org&lt;/a>&lt;/td>
&lt;td>Rate how severe a vulnerability is&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>KEV&lt;/strong>&lt;/td>
&lt;td>Known Exploited Vulnerabilities catalog&lt;/td>
&lt;td>&lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA&lt;/a>&lt;/td>
&lt;td>Track vulnerabilities actively exploited in the wild&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>A CVE tells you &lt;em>what&lt;/em> the vulnerability is. A &lt;a href="https://sbomify.com/2026/02/05/what-is-cvss-vulnerability-scoring/">CVSS&lt;/a> score tells you &lt;em>how bad&lt;/em> it is. A &lt;a href="https://sbomify.com/2025/12/30/what-is-kev-cisa-known-exploited-vulnerabilities/">KEV&lt;/a> listing tells you &lt;em>it is being actively exploited right now&lt;/em>. Effective vulnerability management uses all three signals together.&lt;/p>
&lt;h2 id="the-national-vulnerability-database-nvd">The National Vulnerability Database (NVD)&lt;/h2>
&lt;p>The &lt;a href="https://nvd.nist.gov/">National Vulnerability Database&lt;/a> is the U.S. government&amp;rsquo;s repository of standards-based vulnerability management data. NVD builds on the CVE list by adding:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>CVSS scores&lt;/strong> — severity ratings using the Common Vulnerability Scoring System&lt;/li>
&lt;li>&lt;strong>CPE data&lt;/strong> — Common Platform Enumeration entries that map vulnerabilities to specific products and versions&lt;/li>
&lt;li>&lt;strong>CWE classifications&lt;/strong> — Common Weakness Enumeration categories describing the type of flaw (e.g., buffer overflow, SQL injection)&lt;/li>
&lt;li>&lt;strong>Fix references&lt;/strong> — links to vendor advisories and patches&lt;/li>
&lt;/ul>
&lt;p>NVD is freely accessible and is the primary data source for most vulnerability scanning tools. When a platform like &lt;a href="https://sbomify.com">sbomify&lt;/a>, &lt;a href="https://github.com/anchore/grype">Grype&lt;/a>, or &lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a> scans your software for known issues, it is typically checking component versions against NVD data.&lt;/p>
&lt;h2 id="cve-funding-and-governance">CVE Funding and Governance&lt;/h2>
&lt;p>The CVE program has historically been funded through U.S. government contracts administered by CISA and DHS. In 2025, questions about the sustainability of MITRE&amp;rsquo;s CVE funding drew significant attention from the cybersecurity community. The concern was straightforward: the entire global vulnerability tracking ecosystem depends on a single program funded by a single government.&lt;/p>
&lt;p>In response, the &lt;a href="https://www.cve.org/">CVE Foundation&lt;/a> was established to diversify funding and governance. The CVE Board, an international group of cybersecurity experts, provides strategic oversight. The expansion of the CNA network — now numbering over 400 organizations across 40+ countries — has also distributed the operational workload beyond MITRE alone.&lt;/p>
&lt;p>Regardless of governance structure, the CVE system remains the de facto global standard for vulnerability identification.&lt;/p>
&lt;h2 id="vulnerability-management-with-cves">Vulnerability Management with CVEs&lt;/h2>
&lt;p>Vulnerability management is the continuous process of identifying, evaluating, prioritizing, and remediating security flaws in software. CVEs are the fundamental building blocks of this process.&lt;/p>
&lt;h3 id="the-vulnerability-management-lifecycle">The Vulnerability Management Lifecycle&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>Discover&lt;/strong> — Inventory all software components in your environment (this is where SBOMs are critical)&lt;/li>
&lt;li>&lt;strong>Identify&lt;/strong> — Match your components against known CVEs using vulnerability scanners&lt;/li>
&lt;li>&lt;strong>Evaluate&lt;/strong> — Assess severity using CVSS scores, exploit availability (KEV status), and your own risk context&lt;/li>
&lt;li>&lt;strong>Prioritize&lt;/strong> — Not all CVEs require immediate action. Focus on high-severity vulnerabilities in internet-facing or critical systems, especially those listed in the &lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA KEV catalog&lt;/a>&lt;/li>
&lt;li>&lt;strong>Remediate&lt;/strong> — Apply patches, update dependencies, or implement mitigations&lt;/li>
&lt;li>&lt;strong>Verify&lt;/strong> — Confirm the fix was applied and re-scan to ensure the vulnerability is resolved&lt;/li>
&lt;/ol>
&lt;h3 id="vulnerability-scanners-and-scanning-tools">Vulnerability Scanners and Scanning Tools&lt;/h3>
&lt;p>Several categories of tools support CVE-based vulnerability management:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://sbomify.com/2026/01/11/software-composition-analysis-sca/">Software Composition Analysis (SCA)&lt;/a>&lt;/strong> tools scan open source dependencies for known CVEs. Examples include &lt;a href="https://github.com/anchore/grype">Grype&lt;/a>, &lt;a href="https://snyk.io/">Snyk&lt;/a>, and &lt;a href="https://github.com/aquasecurity/trivy">Trivy&lt;/a>.&lt;/li>
&lt;li>&lt;strong>Container scanners&lt;/strong> analyze Docker and OCI images for vulnerable packages. See our &lt;a href="https://sbomify.com/guides/docker/">Docker SBOM guide&lt;/a> for details.&lt;/li>
&lt;li>&lt;strong>Network vulnerability scanners&lt;/strong> probe running systems for known flaws.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://sbomify.com/2026/02/01/sbom-scanning-vulnerability-detection/">SBOM-based analysis&lt;/a>&lt;/strong> platforms like &lt;a href="https://sbomify.com">sbomify&lt;/a> and &lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a> ingest SBOMs and continuously monitor components against new CVE disclosures.&lt;/li>
&lt;/ul>
&lt;p>See our &lt;a href="https://sbomify.com/resources/">resources page&lt;/a> for a complete list of vulnerability scanning and SBOM analysis tools.&lt;/p>
&lt;p>The key advantage of SBOM-based scanning is that it decouples vulnerability identification from the build process. Once you have an SBOM, you can re-scan it at any time as new CVEs are published — without needing access to the source code or build system.&lt;/p>
&lt;h2 id="how-sboms-enable-rapid-cve-response">How SBOMs Enable Rapid CVE Response&lt;/h2>
&lt;p>The value of a &lt;a href="https://sbomify.com/what-is-sbom/">Software Bill of Materials&lt;/a> becomes most obvious during a vulnerability incident. Consider the Log4Shell scenario (CVE-2021-44228, disclosed December 2021):&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Without SBOMs:&lt;/strong> Teams had to manually audit every application, check dependency files, search through build systems, and contact vendors to determine if they were using Apache Log4j. This took many organizations days or weeks.&lt;/li>
&lt;li>&lt;strong>With SBOMs:&lt;/strong> A simple search across your SBOM repository for &lt;code>org.apache.logging.log4j:log4j-core&lt;/code> returned a complete list of affected applications in minutes.&lt;/li>
&lt;/ul>
&lt;p>This is why compliance frameworks increasingly mandate SBOMs. The &lt;a href="https://sbomify.com/compliance/eu-cra/">EU Cyber Resilience Act&lt;/a> requires manufacturers to identify and document components in their products. &lt;a href="https://sbomify.com/compliance/eo-14028/">Executive Order 14028&lt;/a> requires software vendors to the U.S. government to provide SBOMs. The &lt;a href="https://sbomify.com/compliance/cisa-minimum-elements/">CISA minimum elements&lt;/a> specify that SBOMs should include unique identifiers (such as &lt;a href="https://github.com/package-url/purl-spec">Package URL&lt;/a>) that can be matched against CVE-affected component data.&lt;/p>
&lt;p>To start generating SBOMs for your projects, see our &lt;a href="https://sbomify.com/guides/">language-specific SBOM guides&lt;/a> covering Python, JavaScript, Java, Go, Rust, and more.&lt;/p>
&lt;h2 id="notable-cves-that-changed-the-industry">Notable CVEs That Changed the Industry&lt;/h2>
&lt;p>Several high-profile CVEs have shaped how the industry approaches vulnerability management:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>CVE-2014-0160 (Heartbleed)&lt;/strong> — A critical flaw in OpenSSL that exposed encrypted communications for millions of servers. Highlighted the risk of widely shared dependencies.&lt;/li>
&lt;li>&lt;strong>CVE-2017-5638 (Apache Struts)&lt;/strong> — The vulnerability behind the Equifax breach, which exposed personal data of 147 million people. Demonstrated the consequences of slow patching.&lt;/li>
&lt;li>&lt;strong>CVE-2021-44228 (Log4Shell)&lt;/strong> — A remote code execution flaw in Apache Log4j that affected millions of applications. Became the catalyst for widespread SBOM adoption as organizations struggled to identify affected systems.&lt;/li>
&lt;li>&lt;strong>CVE-2024-3094 (XZ Utils)&lt;/strong> — A supply chain attack where a malicious contributor inserted a backdoor into the XZ compression library. Showed that vulnerabilities can be deliberately introduced, not just accidentally created.&lt;/li>
&lt;/ul>
&lt;p>Each of these incidents reinforced the same lesson: you cannot protect what you cannot see. SBOMs provide that visibility.&lt;/p>
&lt;h2 id="best-practices-for-cve-management">Best Practices for CVE Management&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Maintain SBOMs for all your software.&lt;/strong> An accurate component inventory is the foundation of effective vulnerability management. Use automated tools to &lt;a href="https://sbomify.com/guides/">generate SBOMs&lt;/a> as part of your CI/CD pipeline.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Automate vulnerability scanning.&lt;/strong> Integrate SBOM-based scanning tools into your build and deployment process. Continuous monitoring catches newly disclosed CVEs without manual effort.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Use multiple severity signals.&lt;/strong> Do not rely on CVSS scores alone. Factor in KEV status (is it being exploited?), your deployment context (is the component exposed?), and exploit maturity.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Establish a patching SLA.&lt;/strong> Define response timeframes based on severity. Critical CVEs in exposed systems should be addressed within days, not months.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Subscribe to advisories.&lt;/strong> Monitor the &lt;a href="https://nvd.nist.gov/vuln/data-feeds">NVD data feeds&lt;/a>, vendor security bulletins, and the &lt;a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">CISA KEV catalog&lt;/a> for timely notification of new CVEs affecting your stack.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Document your response process.&lt;/strong> When the next Log4Shell-scale event happens, you need a practiced runbook — not a scramble. SBOMs, pre-defined escalation paths, and automated alerting make the difference.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="frequently-asked-questions">Frequently Asked Questions&lt;/h2>
&lt;h3 id="what-does-cve-stand-for">What does CVE stand for?&lt;/h3>
&lt;p>CVE stands for Common Vulnerabilities and Exposures. It is a system for assigning unique identifiers to publicly known cybersecurity vulnerabilities. Each CVE ID (e.g., CVE-2021-44228) serves as a standard reference that security teams, vendors, and tools can use to unambiguously identify a specific flaw.&lt;/p>
&lt;h3 id="what-is-the-difference-between-a-cve-and-a-vulnerability">What is the difference between a CVE and a vulnerability?&lt;/h3>
&lt;p>A vulnerability is any security weakness in software that could be exploited. A CVE is the standardized identifier assigned to a publicly known vulnerability. Not all vulnerabilities have CVE IDs — only those that are publicly disclosed and meet the CVE program&amp;rsquo;s inclusion criteria receive a CVE number. Think of CVE as the naming system, and vulnerability as the broader concept.&lt;/p>
&lt;h3 id="who-assigns-cve-numbers">Who assigns CVE numbers?&lt;/h3>
&lt;p>CVE IDs are assigned by CVE Numbering Authorities (CNAs). MITRE Corporation serves as the primary CNA and coordinates the overall program. Over 400 organizations, including major software vendors like Microsoft, Google, and Red Hat, are authorized to assign CVE IDs within their product scope. Researchers can also request CVE IDs through the &lt;a href="https://www.cve.org/ResourcesSupport/ReportRequest">CVE Request form&lt;/a>.&lt;/p>
&lt;h3 id="how-are-cves-used-in-vulnerability-management">How are CVEs used in vulnerability management?&lt;/h3>
&lt;p>CVEs are the foundation of vulnerability management. Organizations use vulnerability scanners and Software Composition Analysis tools to match their software components against known CVEs. When a match is found, the CVSS severity score and KEV status help prioritize remediation. SBOMs make this process more efficient by providing a complete component inventory that can be continuously rescanned.&lt;/p>
&lt;h3 id="what-is-the-national-vulnerability-database-nvd">What is the National Vulnerability Database (NVD)?&lt;/h3>
&lt;p>The NVD is the U.S. government&amp;rsquo;s repository of vulnerability data, maintained by NIST. It enriches CVE entries with severity scores (CVSS), affected product mappings (CPE), weakness classifications (CWE), and references to patches. Most vulnerability scanning tools use NVD as their primary data source.&lt;/p></description><category>education</category></item><item><title>Software Development Life Cycle (SDLC): A Complete Guide</title><link>https://sbomify.com/2025/12/15/software-development-life-cycle-sdlc-sbom-integration/</link><pubDate>Mon, 15 Dec 2025 00:00:00 +0000</pubDate><guid>https://sbomify.com/2025/12/15/software-development-life-cycle-sdlc-sbom-integration/</guid><description>&lt;p>The Software Development Life Cycle (SDLC) is a structured process that defines the stages involved in developing software from initial concept through deployment and maintenance. SDLC provides a systematic framework that development teams use to plan, create, test, and deliver high-quality software. Understanding the SDLC is essential for any organization building software today, particularly as security and compliance requirements become integral to every phase of development.&lt;/p>
&lt;p>&lt;img src="https://sbomify.com/assets/images/d2/sdlc-sbom.svg" alt="SDLC phases with SBOM integration points">&lt;/p>
&lt;h2 id="what-is-the-software-development-life-cycle">What Is the Software Development Life Cycle?&lt;/h2>
&lt;p>SDLC, short for Software Development Life Cycle, is a methodology used by software engineering teams to design, develop, and test software in a predictable and efficient manner. Rather than writing code ad hoc, SDLC defined processes ensure that each stage of development has clear objectives, deliverables, and quality checks.&lt;/p>
&lt;p>The concept of a structured development life cycle emerged in the 1960s as software projects grew in complexity. What began as a simple sequential process has evolved into a family of software development life cycle models, each suited to different project types and organizational needs.&lt;/p>
&lt;p>At its core, every SDLC framework answers the same questions: What are we building? How will we build it? How do we know it works? And how do we keep it running?&lt;/p>
&lt;h2 id="the-phases-of-the-sdlc">The Phases of the SDLC&lt;/h2>
&lt;p>While specific terminology varies between models, most SDLC frameworks include six to eight phases. Here are the core stages that appear in virtually every approach.&lt;/p>
&lt;h3 id="1-planning-and-requirements-analysis">1. Planning and Requirements Analysis&lt;/h3>
&lt;p>The first phase involves gathering business requirements, identifying stakeholders, and defining project scope. Teams assess feasibility, estimate resources, and create a project plan. Security considerations should enter the picture here through threat modeling and risk assessment.&lt;/p>
&lt;h3 id="2-system-design">2. System Design&lt;/h3>
&lt;p>Architects and senior developers translate requirements into a technical blueprint. This includes system architecture, technology stack selection, data models, and interface specifications. Design decisions made here have long-lasting implications for security and maintainability.&lt;/p>
&lt;h3 id="3-implementation-coding">3. Implementation (Coding)&lt;/h3>
&lt;p>Developers write the actual source code based on the design specifications. This phase typically involves selecting libraries, frameworks, and third-party components. These &lt;a href="https://sbomify.com/2026/01/29/what-is-a-dependency-in-software/">dependency&lt;/a> choices directly impact the &lt;a href="https://sbomify.com/2025/12/26/software-supply-chain-management/">software supply chain&lt;/a> and are the foundation of what an &lt;a href="https://sbomify.com/what-is-sbom/">SBOM&lt;/a> will eventually document.&lt;/p>
&lt;h3 id="4-testing">4. Testing&lt;/h3>
&lt;p>Quality assurance teams verify that the software meets requirements and is free of defects. Testing includes unit tests, integration tests, system tests, and user acceptance testing. Security testing, including vulnerability scanning and penetration testing, is increasingly part of this phase.&lt;/p>
&lt;h3 id="5-deployment">5. Deployment&lt;/h3>
&lt;p>The tested software is released to production environments. Deployment strategies such as blue-green deployments, canary releases, and rolling updates help reduce risk. This phase is where CI/CD pipelines automate the build, test, and release process.&lt;/p>
&lt;h3 id="6-maintenance-and-operations">6. Maintenance and Operations&lt;/h3>
&lt;p>After deployment, teams monitor the application, fix bugs, apply security patches, and release updates. This phase often lasts the longest and is where vulnerability management and ongoing compliance activities take place.&lt;/p>
&lt;h2 id="software-development-life-cycle-models">Software Development Life Cycle Models&lt;/h2>
&lt;p>Over the decades, several SDLC models have emerged to address different project needs. Each model organizes the core phases differently.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Model&lt;/th>
&lt;th>Approach&lt;/th>
&lt;th>Best Suited For&lt;/th>
&lt;th>Key Characteristic&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Waterfall&lt;/strong>&lt;/td>
&lt;td>Sequential, linear&lt;/td>
&lt;td>Well-defined projects with stable requirements&lt;/td>
&lt;td>Each phase completes before the next begins&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Agile&lt;/strong>&lt;/td>
&lt;td>Iterative, incremental&lt;/td>
&lt;td>Projects with evolving requirements&lt;/td>
&lt;td>Short sprints, continuous feedback&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Spiral&lt;/strong>&lt;/td>
&lt;td>Risk-driven, iterative&lt;/td>
&lt;td>Large, high-risk projects&lt;/td>
&lt;td>Risk analysis at every iteration&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>V-Model&lt;/strong>&lt;/td>
&lt;td>Verification and validation&lt;/td>
&lt;td>Safety-critical and regulated systems&lt;/td>
&lt;td>Each development phase has a corresponding test phase&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>DevOps&lt;/strong>&lt;/td>
&lt;td>Continuous integration and delivery&lt;/td>
&lt;td>Fast-moving organizations&lt;/td>
&lt;td>Merges development and operations&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Lean&lt;/strong>&lt;/td>
&lt;td>Waste elimination&lt;/td>
&lt;td>Startups and rapid prototyping&lt;/td>
&lt;td>Minimize overhead, maximize value&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The Waterfall model was the original SDLC approach, moving linearly from requirements through deployment. Agile methodologies, including Scrum and Kanban, replaced the rigid sequential approach with iterative cycles that deliver working software in short sprints. Most modern teams use some form of Agile combined with DevOps practices.&lt;/p>
&lt;h2 id="where-security-fits-from-sdlc-to-secure-sdlc">Where Security Fits: From SDLC to Secure SDLC&lt;/h2>
&lt;p>Traditional SDLC models treated security as a gate at the end of development — a final check before release. This approach consistently proved inadequate. Vulnerabilities discovered late in the cycle are far more expensive to fix than those caught early.&lt;/p>
&lt;p>The Secure Software Development Life Cycle (SSDLC or Secure SDLC) integrates security activities into every phase:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Planning:&lt;/strong> Threat modeling, security requirements definition&lt;/li>
&lt;li>&lt;strong>Design:&lt;/strong> Security architecture review, attack surface analysis&lt;/li>
&lt;li>&lt;strong>Implementation:&lt;/strong> Secure coding standards, dependency management, SBOM generation&lt;/li>
&lt;li>&lt;strong>Testing:&lt;/strong> Static Application Security Testing (SAST), Dynamic Application Security Testing (DAST), &lt;a href="https://sbomify.com/2026/01/11/software-composition-analysis-sca/">Software Composition Analysis (SCA)&lt;/a>&lt;/li>
&lt;li>&lt;strong>Deployment:&lt;/strong> Configuration hardening, secrets management, SBOM distribution&lt;/li>
&lt;li>&lt;strong>Maintenance:&lt;/strong> Vulnerability monitoring, patch management, SBOM updates&lt;/li>
&lt;/ul>
&lt;p>This shift-left approach — moving security earlier in the development process — is central to &lt;a href="https://www.nist.gov/publications/devsecops-nist-special-publication-800-218-secure-software-development-framework-ssdf">DevSecOps&lt;/a>, where security becomes a shared responsibility across the entire team rather than a bottleneck at the end.&lt;/p>
&lt;h2 id="sdlc-and-sboms-integration-at-every-phase">SDLC and SBOMs: Integration at Every Phase&lt;/h2>
&lt;p>A &lt;a href="https://sbomify.com/what-is-sbom/">Software Bill of Materials&lt;/a> (SBOM) documents every component, library, and dependency in a piece of software. Rather than treating SBOM generation as a one-time event, modern organizations integrate SBOMs throughout the SDLC.&lt;/p>
&lt;h3 id="during-implementation">During Implementation&lt;/h3>
&lt;p>When developers add dependencies — open source libraries, frameworks, and packages — they shape the software&amp;rsquo;s composition. This is the moment to begin tracking what goes into the build. Tools like the &lt;a href="https://github.com/sbomify/github-action/">sbomify GitHub Action&lt;/a> can generate SBOMs automatically as part of the build process. See our &lt;a href="https://sbomify.com/guides/">SBOM generation guides&lt;/a> for language-specific instructions covering Python, JavaScript, Java, Go, Rust, and more.&lt;/p>
&lt;h3 id="during-testing">During Testing&lt;/h3>
&lt;p>SBOMs enable automated &lt;a href="https://sbomify.com/2026/02/01/sbom-scanning-vulnerability-detection/">vulnerability scanning&lt;/a>. Once you have a complete inventory of components, platforms like &lt;a href="https://sbomify.com">sbomify&lt;/a> can continuously monitor your SBOMs against vulnerability databases. Standalone tools like &lt;a href="https://github.com/anchore/grype">Grype&lt;/a> and &lt;a href="https://dependencytrack.org/">OWASP Dependency-Track&lt;/a> can also cross-reference your SBOM against the &lt;a href="https://nvd.nist.gov/">National Vulnerability Database&lt;/a> (NVD) and &lt;a href="https://osv.dev/">OSV&lt;/a>. See our &lt;a href="https://sbomify.com/resources/">resources page&lt;/a> for a complete list of SBOM generation and analysis tools.&lt;/p>
&lt;h3 id="during-deployment">During Deployment&lt;/h3>
&lt;p>The SBOM becomes a release artifact alongside the software itself. Compliance frameworks including the &lt;a href="https://sbomify.com/compliance/eu-cra/">EU Cyber Resilience Act&lt;/a> and &lt;a href="https://sbomify.com/compliance/eo-14028/">Executive Order 14028&lt;/a> require SBOMs to be available to downstream consumers. Signing the SBOM provides tamper-evidence for the supply chain.&lt;/p>
&lt;h3 id="during-maintenance">During Maintenance&lt;/h3>
&lt;p>As new vulnerabilities are discovered — often months or years after deployment — SBOMs allow organizations to quickly determine whether they are affected. When the &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-44228">Log4Shell vulnerability&lt;/a> was disclosed in December 2021, organizations with SBOMs could identify affected systems in minutes rather than weeks.&lt;/p>
&lt;h2 id="sdlc-best-practices-for-modern-teams">SDLC Best Practices for Modern Teams&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Choose the right model for your context.&lt;/strong> Agile works well for most web and cloud applications. V-Model or Spiral may be more appropriate for safety-critical systems in medical devices or automotive software.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Shift security left.&lt;/strong> Integrate threat modeling in planning, dependency review in implementation, and automated security testing in CI/CD. Catching vulnerabilities early saves time and reduces risk.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Automate everything repeatable.&lt;/strong> Use CI/CD pipelines to automate builds, tests, security scans, SBOM generation, and deployments. Manual processes introduce inconsistency and slow the cycle.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Track your dependencies.&lt;/strong> Every third-party library is a potential risk vector. Maintain SBOMs, monitor for vulnerabilities, and have a process for updating or replacing compromised components.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Build compliance into the workflow.&lt;/strong> Rather than scrambling for compliance at audit time, embed &lt;a href="https://sbomify.com/guides/">SBOM generation&lt;/a> and vulnerability scanning into your standard SDLC process. This is especially critical for organizations subject to the &lt;a href="https://sbomify.com/compliance/ntia-minimum-elements/">NTIA minimum elements&lt;/a> or &lt;a href="https://sbomify.com/compliance/cisa-minimum-elements/">CISA guidance&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Measure and improve.&lt;/strong> Track metrics like lead time, deployment frequency, mean time to recovery, and vulnerability remediation time. Use retrospectives to continuously improve the process.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="nist-and-the-sdlc">NIST and the SDLC&lt;/h2>
&lt;p>The National Institute of Standards and Technology (NIST) has published several frameworks relevant to securing the SDLC:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://csrc.nist.gov/pubs/sp/800/218/final">NIST SP 800-218&lt;/a>&lt;/strong> (Secure Software Development Framework, SSDF) provides practices for integrating security into the development process, organized into four groups: Prepare the Organization, Protect the Software, Produce Well-Secured Software, and Respond to Vulnerabilities.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://csrc.nist.gov/pubs/sp/800/53/r5/upd1/final">NIST SP 800-53&lt;/a>&lt;/strong> includes the SA (System and Services Acquisition) and SR (Supply Chain Risk Management) control families that directly address SDLC security controls.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://www.nist.gov/cyberframework">NIST Cybersecurity Framework 2.0&lt;/a>&lt;/strong> provides a high-level structure for managing cybersecurity risk that maps to SDLC activities.&lt;/li>
&lt;/ul>
&lt;p>These frameworks are increasingly referenced in procurement requirements and regulatory compliance, making them essential reading for teams working on government or critical infrastructure projects.&lt;/p>
&lt;h2 id="frequently-asked-questions">Frequently Asked Questions&lt;/h2>
&lt;h3 id="what-is-sdlc-in-software-development">What is SDLC in software development?&lt;/h3>
&lt;p>SDLC stands for Software Development Life Cycle. It is a structured process that guides software development from initial planning through deployment and ongoing maintenance. The SDLC provides a framework of phases — including requirements analysis, design, implementation, testing, deployment, and maintenance — that help teams deliver reliable software in a systematic way.&lt;/p>
&lt;h3 id="what-are-the-most-common-sdlc-models">What are the most common SDLC models?&lt;/h3>
&lt;p>The most widely used software development life cycle models are Waterfall, Agile (including Scrum and Kanban), DevOps, V-Model, Spiral, and Lean. Agile and DevOps are the most popular for modern web and cloud applications due to their iterative approach and emphasis on continuous delivery.&lt;/p>
&lt;h3 id="how-do-sboms-fit-into-the-sdlc">How do SBOMs fit into the SDLC?&lt;/h3>
&lt;p>SBOMs integrate into multiple SDLC phases. During implementation, SBOM generation tools capture component inventories. During testing, SBOMs enable automated vulnerability scanning. During deployment, SBOMs are distributed alongside release artifacts for compliance. During maintenance, SBOMs allow rapid identification of affected systems when new vulnerabilities are disclosed. See our &lt;a href="https://sbomify.com/guides/">SBOM generation guides&lt;/a> for language-specific integration steps.&lt;/p>
&lt;h3 id="what-is-the-difference-between-sdlc-and-devops">What is the difference between SDLC and DevOps?&lt;/h3>
&lt;p>SDLC is the overall process framework for software development, while DevOps is a specific approach that emphasizes collaboration between development and operations teams with a focus on automation, continuous integration, and continuous delivery. DevOps can be seen as a modern SDLC model rather than an alternative to the SDLC concept itself.&lt;/p>
&lt;h3 id="what-is-a-secure-sdlc">What is a Secure SDLC?&lt;/h3>
&lt;p>A Secure SDLC (sometimes called SSDLC) integrates security practices into every phase of the software development life cycle, rather than treating security as a final checkpoint. This includes threat modeling during planning, secure coding standards during implementation, SAST/DAST during testing, and vulnerability monitoring during maintenance. NIST SP 800-218 (SSDF) provides a standardized framework for implementing a Secure SDLC.&lt;/p></description><category>education</category></item><item><title>How SBOMs Can Help You Achieve PCI DSS 4.0 Compliance</title><link>https://sbomify.com/2025/01/07/how-sboms-can-help-you-achieve-pci-dss-4-compliance/</link><pubDate>Tue, 07 Jan 2025 09:00:00 +0000</pubDate><guid>https://sbomify.com/2025/01/07/how-sboms-can-help-you-achieve-pci-dss-4-compliance/</guid><description>&lt;h3 id="what-is-pci-dss-40">What Is PCI DSS 4.0?&lt;/h3>
&lt;p>The Payment Card Industry Data Security Standard (PCI DSS) is a set of security standards designed to ensure that companies that process, store, or transmit credit card information maintain a secure environment. PCI DSS 4.0 is the latest evolution of these standards, released to:&lt;/p>
&lt;ul>
&lt;li>Address emerging threats&lt;/li>
&lt;li>Improve security practices&lt;/li>
&lt;li>Provide more flexibility in how organizations meet their security requirements&lt;/li>
&lt;/ul>
&lt;p>Online gambling platforms and e-commerce businesses are especially impacted by PCI DSS 4.0, given their high volume of transactions and the critical nature of protecting cardholder data. CTOs, CISOs, and other security leaders in these industries must ensure their systems and processes comply with PCI DSS to avoid costly breaches and non-compliance penalties.&lt;/p>
&lt;h3 id="what-are-sboms">What Are SBOMs?&lt;/h3>
&lt;p>A Software Bill of Materials (SBOM) is an inventory list of all the components (libraries, modules, frameworks, etc.) that go into creating a software application or system. Think of an SBOM as a detailed recipe for your software. It helps you understand:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>What open-source or proprietary components&lt;/strong> are in your applications&lt;/li>
&lt;li>&lt;strong>Which versions&lt;/strong> of those components are deployed&lt;/li>
&lt;li>&lt;strong>Where&lt;/strong> (in which products, projects, or services) these components are used&lt;/li>
&lt;/ul>
&lt;p>SBOMs provide insight into potential security vulnerabilities and compliance risks arising from the software supply chain. For example, knowing exactly which version of an open-source library is integrated into your payment-processing application can be a game-changer if a critical vulnerability is discovered in that library.&lt;/p>
&lt;h3 id="why-sboms-are-the-solution-for-pci-dss-compliance">Why SBOMs Are the Solution for PCI DSS Compliance&lt;/h3>
&lt;p>PCI DSS 4.0 emphasizes &lt;strong>continuous risk assessments, vulnerability management, and secure software development practices&lt;/strong>. These objectives hinge on being able to:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Identify Vulnerabilities Quickly&lt;/strong>: You can&amp;rsquo;t protect what you don&amp;rsquo;t know exists. SBOMs offer a transparent, human-readable list of all your software components, making it easier to detect known vulnerabilities.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Maintain Detailed Audit Trails&lt;/strong>: PCI DSS requires organizations to maintain accurate records that prove you&amp;rsquo;re following security best practices. SBOMs serve as a living documentation of your software&amp;rsquo;s composition, making audits less cumbersome.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Establish Accountability&lt;/strong>: With an SBOM, teams can be held accountable for the components they choose and the updates or patches they apply (or don&amp;rsquo;t apply). That traceability is crucial for demonstrating compliance.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>In industries like online gambling and e-commerce, where applications change rapidly due to continuous feature deployment, having an SBOM means you can react fast. Instead of scrambling to figure out where a newly discovered vulnerability might exist, you already have a reliable, up-to-date inventory of your software components.&lt;/p>
&lt;h3 id="how-sbomify-simplifies-sbom-management">How sbomify Simplifies SBOM Management&lt;/h3>
&lt;p>At &lt;a href="https://sbomify.com">sbomify&lt;/a>, we understand that creating SBOMs is just the first step. Managing them, especially for a portfolio of applications, can quickly become &lt;strong>time-consuming&lt;/strong> and &lt;strong>error-prone&lt;/strong>. That&amp;rsquo;s why we developed features to help you &lt;strong>organize&lt;/strong>, &lt;strong>review&lt;/strong>, and &lt;strong>aggregate&lt;/strong> your SBOM data effectively.&lt;/p>
&lt;h4 id="sbom-hierarchy-products-projects-and-components">SBOM Hierarchy: Products, Projects, and Components&lt;/h4>
&lt;p>Our platform offers a &lt;strong>hierarchical approach&lt;/strong> to managing SBOMs:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Component-Level&lt;/strong>: Each SBOM represents the building blocks (think individual libraries or modules)&lt;/li>
&lt;li>&lt;strong>Project-Level&lt;/strong>: Projects aggregate multiple SBOMs. For instance, if your e-commerce platform consists of a front-end, back-end, and payment gateway, each part has its own SBOM, but you can view them collectively under the same project&lt;/li>
&lt;li>&lt;strong>Product-Level&lt;/strong>: For organizations that have multiple projects, such as a gaming platform, payment processor, and marketing tool, you can roll up all those SBOMs into one product-level view&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Why does this matter?&lt;/strong> Because PCI DSS isn&amp;rsquo;t limited to just one application, it concerns your entire environment handling payment data. By grouping and reviewing SBOMs at different levels, you can quickly identify shared vulnerabilities or outdated components &lt;strong>across&lt;/strong> your organization.&lt;/p>
&lt;p>&lt;a href="https://sbomify.com/features/sbom-hierarchy/">Learn more about SBOM hierarchy&lt;/a>&lt;/p>
&lt;h3 id="managing-complex-environments-with-a-central-sbom-hub">Managing Complex Environments With a Central SBOM Hub&lt;/h3>
&lt;p>In a modern DevOps or Continuous Integration/Continuous Deployment (CI/CD) environment, multiple teams and sometimes multiple CI/CD tools (GitHub Actions, Jenkins, Azure DevOps, etc.) generate SBOMs. This can create a scattered ecosystem where no single dashboard gives you a unified view of your software&amp;rsquo;s entire composition.&lt;/p>
&lt;p>&lt;strong>Why a Central SBOM Hub Is Essential&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Consolidated Visibility&lt;/strong>: Bring together SBOMs from various build pipelines so you don&amp;rsquo;t miss any critical updates or vulnerabilities&lt;/li>
&lt;li>&lt;strong>Streamlined Processes&lt;/strong>: Standardize how you generate, store, and review SBOMs. This makes audits simpler and reduces manual overhead&lt;/li>
&lt;li>&lt;strong>Compliance at Scale&lt;/strong>: As your organization grows, so does your software environment. A central hub ensures you can scale your compliance program without chaos&lt;/li>
&lt;/ul>
&lt;p>Having a one-stop shop for all your SBOMs is particularly crucial in online gambling and e-commerce, where you might have multiple services (like account management, game or product catalogs, payment gateways, and marketing analytics) each built by different teams. PCI DSS 4.0 compliance depends on your ability to keep track of all these moving parts and prove that every software component meets security requirements.&lt;/p>
&lt;h3 id="a-look-ahead-compliance-beyond-pci-dss">A Look Ahead: Compliance Beyond PCI DSS&lt;/h3>
&lt;p>While this post focuses on PCI DSS 4.0, it&amp;rsquo;s important to note that &lt;strong>other compliance frameworks&lt;/strong> are increasingly looking at software supply chain security and requiring a robust accounting of your software components. Notable examples include:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>EU Cyber Resilience Act&lt;/strong>: This upcoming regulation in the European Union will likely mandate stricter controls around software supply chains and could require SBOMs&lt;/li>
&lt;li>&lt;strong>ISO/IEC 27001&lt;/strong>: This widely recognized standard for information security management also emphasizes risk management of software assets&lt;/li>
&lt;li>&lt;strong>Industry-Specific Regulations&lt;/strong>: Sectors like healthcare (HIPAA) and finance (FFIEC) are adopting similar stances, pushing for greater transparency and vulnerability management in software&lt;/li>
&lt;/ol>
&lt;p>Being proactive now by implementing SBOMs and centralizing their management will prepare your organization to meet these evolving demands head-on.&lt;/p>
&lt;h3 id="conclusion">Conclusion&lt;/h3>
&lt;p>PCI DSS 4.0 sets the bar high for payment security, requiring organizations to be vigilant, transparent, and accountable in how they handle cardholder data. &lt;strong>SBOMs are a powerful tool&lt;/strong> in meeting these requirements because they give security teams the visibility and traceability they need to manage vulnerabilities and prove compliance.&lt;/p>
&lt;p>&lt;a href="https://sbomify.com">sbomify&lt;/a> goes a step further by making &lt;strong>SBOM management simpler&lt;/strong>, offering product, project, and component-level views and a central hub for consolidating all your SBOMs. If you operate in online gambling or e-commerce, where the risks and compliance stakes are especially high, adopting a single, centralized platform to manage your SBOMs is no longer optional, it&amp;rsquo;s essential.&lt;/p>
&lt;p>Ready to take control of your software supply chain and secure your path to PCI DSS 4.0 compliance?
&lt;a href="https://sbomify.com/">Get started with sbomify&lt;/a>&lt;/p></description><category>compliance</category></item><item><title>Introducing sbomify: Revolutionizing SBOM Management</title><link>https://sbomify.com/2024/08/29/launching-sbomify/</link><pubDate>Thu, 29 Aug 2024 00:00:00 +0000</pubDate><guid>https://sbomify.com/2024/08/29/launching-sbomify/</guid><description>&lt;p>We’re excited to announce the launch of sbomify, a platform designed to transform how businesses manage and share Software Bill of Materials (SBOMs). Our journey to create sbomify began with a clear observation — many companies, particularly those in regulated industries, are struggling to keep up with the increasing demand for SBOMs. This need has only intensified with mandates like the US Executive Order 14028, the upcoming EU Cyber Resilience Act, and the CISA&amp;rsquo;s &lt;a href="https://www.cisa.gov/securebydesign">Secure by Design&lt;/a> initiative, which calls for radical transparency in software development.&lt;/p>
&lt;p>As the founder of &lt;a href="https://www.screenly.io">Screenly&lt;/a>, I observed firsthand the growing challenges software vendors face when it comes to managing and sharing SBOMs. It became glaringly obvious that manually sending SBOMs to customers via email or storing them on internal file servers was completely unrealistic. The process was not only time-consuming but also prone to errors and delays, making it an inefficient way to ensure that customers had access to the most up-to-date information. This challenge is further emphasized in CISA’s &lt;a href="https://www.cisa.gov/sites/default/files/publications/Sharing-SBOMs-Primer-CISA-508.pdf">Sharing Primer on SBOMs&lt;/a>, which highlights the importance of efficient and secure SBOM sharing practices.&lt;/p>
&lt;p>Over the past year, I’ve also had numerous conversations with CTOs and CISOs across various industries about how they currently manage SBOMs. It became clear that most companies are still relying on manual processes to handle these critical documents. Whether it&amp;rsquo;s through email, internal file shares, or other outdated methods, the consensus was that there had to be a better way—one that aligns with the dynamic nature of SBOMs in modern CI/CD environments.&lt;/p>
&lt;p>This is where sbomify comes in.&lt;/p>
&lt;p>sbomify automates the entire SBOM management process by integrating directly with your CI/CD pipeline. With each new release, the latest SBOM is automatically uploaded to sbomify, providing stakeholders with instant, real-time access. No more cumbersome email chains or dealing with outdated files — sbomify ensures your SBOMs are always up-to-date and easily accessible.&lt;/p>
&lt;p>To understand how sbomify fits into the SBOM ecosystem, it’s essential to recognize the three key parts of the SBOM life cycle: &lt;a href="https://sbomify.com/features/generate-collaborate-analyze/">&lt;strong>generation, collaboration, and analysis&lt;/strong>&lt;/a>. sbomify focuses purely on the collaboration aspect, ensuring that once SBOMs are generated, they can be easily shared and accessed in real-time by all relevant stakeholders. We believe that efficient collaboration is the backbone of effective SBOM management, which is why we’ve built sbomify to excel in this area.&lt;/p>
&lt;p>&lt;img src="https://sbomify.com/assets/images/site/marketplace.webp" alt="SBOM hub">&lt;/p>
&lt;p>However, we also recognize the importance of the other two components - generation and analysis. That’s why sbomify will be partnering and integrating with leading third-party providers who specialize in these areas. Our goal is to create a seamless experience where SBOMs can be generated, collaborated on, and analyzed, all through interconnected tools that work together to ensure comprehensive SBOM management.&lt;/p>
&lt;p>We’re excited about the possibilities sbomify offers and would love to hear your thoughts or discuss how it can benefit your organization.&lt;/p>
&lt;p>You can request early access up using &lt;a href="https://docs.google.com/forms/d/e/1FAIpQLSe1-SCbmyPnhHxP1RHIYi4iKP2CLy6SXcqFOP1i7B8VHZJYkw/viewform?usp=sf_link">this form&lt;/a>.&lt;/p></description><category>announcement</category></item><item><title>Exploring the Future of Software Security: Join Us at BSides Bristol</title><link>https://sbomify.com/2024/08/26/bsides-bristol/</link><pubDate>Mon, 26 Aug 2024 00:00:00 +0000</pubDate><guid>https://sbomify.com/2024/08/26/bsides-bristol/</guid><description>&lt;p>This weekend marks an exciting event for the cybersecurity community — &lt;a href="https://www.bsidesbristol.org.uk/">BSides Bristol&lt;/a> is officially kicking off! We’re thrilled to be a part of this dynamic conference, where we’ll be presenting a talk on a topic that’s rapidly gaining significance: &lt;a href="https://pretalx.com/bsides-bristol-2024/talk/EX8YC8/">Navigating the SBOM Landscape: Formats, Relevance, and Tooling in 2024&lt;/a>.&lt;/p>
&lt;h2 id="whats-our-talk-about">What’s Our Talk About?&lt;/h2>
&lt;p>In recent years, the concept of a Software Bill of Materials (SBOM) has emerged as a cornerstone of modern cybersecurity practices. With growing global attention—highlighted by the US executive order aimed at enhancing national cybersecurity and the UK’s Code of Practice for Software Vendors - SBOMs are increasingly recognized as essential tools for ensuring software transparency and mitigating risks.&lt;/p>
&lt;p>Our talk is designed to dive deep into the world of SBOMs, exploring why they are becoming indispensable in today’s cybersecurity framework. We’ll discuss the key SBOM formats — SPDX and CycloneDX—offering a detailed look at their features, benefits, and how they contribute to a more secure software ecosystem.&lt;/p>
&lt;p>But understanding the formats is just the beginning. We’ll also provide an overview of the current SBOM tooling landscape, highlighting the technologies that are making it easier for organizations to manage and utilize SBOMs effectively. Whether you’re a developer, a security professional, or a decision-maker, this session will equip you with the knowledge to navigate the SBOM landscape confidently.&lt;/p>
&lt;h2 id="why-should-you-attend">Why Should You Attend?&lt;/h2>
&lt;p>This talk is more than just an introduction to SBOMs. It’s a comprehensive guide to understanding their significance in today’s cybersecurity efforts. You’ll leave with a clear grasp of the different SBOM formats, the state-of-the-art tools available, and practical insights into how these can be applied to enhance software security and ensure regulatory compliance.&lt;/p>
&lt;p>If you’re committed to advancing your organization’s software security practices, this session is one you won’t want to miss.&lt;/p>
&lt;p>We look forward to seeing you at BSides Bristol and engaging in this important conversation about the future of software security.&lt;/p>
&lt;h2 id="update">Update&lt;/h2>
&lt;p>The slides from the talk can be found &lt;a href="https://speakerdeck.com/vpetersson/navigating-the-sbom-landscape-formats-relevance-and-tooling-in-2024-at-bsides-bristol-24">here&lt;/a>.&lt;/p></description><category>news</category></item><item><title>Announcing sbomify&amp;#39;s GitHub Actions Module: Seamlessly Share SBOMs in Your CI/CD Pipeline</title><link>https://sbomify.com/2024/08/21/introducing-github-action-module/</link><pubDate>Wed, 21 Aug 2024 00:00:00 +0000</pubDate><guid>https://sbomify.com/2024/08/21/introducing-github-action-module/</guid><description>&lt;p>We are thrilled to announce the launch of &lt;strong>sbomify&amp;rsquo;s GitHub Actions Module&lt;/strong> — now available in the &lt;a href="https://github.com/marketplace/actions/sbomify">GitHub Marketplace&lt;/a>! This powerful tool simplifies the process of generating Software Bill of Materials (SBOMs) right within your CI/CD pipeline, ensuring that your software components are transparently documented and compliant with industry standards.&lt;/p>
&lt;h2 id="why-sbomify">Why sbomify?&lt;/h2>
&lt;p>As software development evolves, transparency and security have become paramount. A Software Bill of Materials (SBOM) is a detailed list of components used in building a piece of software, allowing teams to manage vulnerabilities, license compliance, and supply chain risks effectively. With sbomify, you can automatically generate SBOMs as part of your development workflow, making it easier to maintain a secure and compliant software development lifecycle.&lt;/p>
&lt;h2 id="introducing-sbomifys-github-actions-module">Introducing sbomify’s GitHub Actions Module&lt;/h2>
&lt;p>The sbomify GitHub Action is designed to integrate seamlessly with your existing CI/CD pipelines, offering:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Automated SBOM Generation&lt;/strong>: Automatically create SBOMs for your software projects as part of your CI/CD process, ensuring consistent documentation across all builds.&lt;/li>
&lt;li>&lt;strong>Compliance and Security&lt;/strong>: Maintain compliance with industry standards and improve your software’s security posture by documenting all dependencies and components.&lt;/li>
&lt;li>&lt;strong>Easy Integration&lt;/strong>: Simply add the sbomify Action to your workflow file, and it takes care of the rest. No complex configurations are required.&lt;/li>
&lt;/ul>
&lt;h2 id="how-to-get-started">How to Get Started&lt;/h2>
&lt;p>Getting started with sbomify is easy! Here&amp;rsquo;s how you can integrate it into your project:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Visit the Marketplace&lt;/strong>: Head over to the &lt;a href="https://github.com/marketplace/actions/sbomify">GitHub Marketplace&lt;/a> to find the sbomify Action.&lt;/li>
&lt;li>&lt;strong>Add sbomify to Your Workflow&lt;/strong>: Add the sbomify Action to your GitHub Actions workflow by modifying your &lt;code>.yml&lt;/code> file(s). You can find detailed setup instructions in the &lt;a href="https://github.com/sbomify/github-action">sbomify GitHub repository&lt;/a>.&lt;/li>
&lt;li>&lt;strong>Run Your Workflow&lt;/strong>: Once integrated, every time your workflow runs, sbomify will automaticaally upload the generated SBOM for your project, which in turn can shared with your stakeholders. No more manual sharing of SBOMs over emails, your stakeholders can automatically pull down the latest SBOM directly from sbomify when they need it, ensuring they always have the latest version.&lt;/li>
&lt;/ol>
&lt;p>Here&amp;rsquo;s a quick example of how to include sbomify in your workflow:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Build and Generate SBOM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">on&lt;/span>: [&lt;span style="color:#ae81ff">push]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">jobs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">build&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">runs-on&lt;/span>: &lt;span style="color:#ae81ff">ubuntu-latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/checkout@v2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Build your SBOM...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Upload SBOM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">sbomify/github-action@master&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">TOKEN&lt;/span>: &lt;span style="color:#ae81ff">${{ secrets.SBOMIFY_TOKEN }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">COMPONENT_ID&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;my-component-id&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">SBOM_FILE&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;sbom-file.json&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">COMPONENT_NAME&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;my-app&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">COMPONENT_VERSION&lt;/span>: &lt;span style="color:#ae81ff">${{ github.ref_name }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">AUGMENT&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ENRICH&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For more details on using the GitHub Action and other CI/CD integrations, see our &lt;a href="https://sbomify.com/features/integrations/">integrations page&lt;/a>.&lt;/p>
&lt;h2 id="not-using-github-actions">Not using GitHub Actions?&lt;/h2>
&lt;p>No problem! Our tool can can easily be integrated in any other CI/CD pipeline. Just get in touch and we&amp;rsquo;ll help you.&lt;/p>
&lt;h2 id="join-us-in-building-more-secure-software">Join Us in Building More Secure Software&lt;/h2>
&lt;p>As software supply chains become increasingly complex, tools like sbomify are essential for maintaining transparency and security. By integrating sbomify into your workflows, you&amp;rsquo;re taking a proactive step towards better software management and compliance.&lt;/p>
&lt;p>We’re excited to see how sbomify will help you build more secure and transparent software. Try it out today by visiting the &lt;a href="https://github.com/marketplace/actions/sbomify">GitHub Marketplace&lt;/a> and start sharing your SBOMs with ease!&lt;/p></description><category>announcement</category></item><item><title>Comparing SBOM Formats: Focus on Component Types in CycloneDX vs. SPDX</title><link>https://sbomify.com/2024/08/20/sbom-component-types/</link><pubDate>Tue, 20 Aug 2024 00:00:00 +0000</pubDate><guid>https://sbomify.com/2024/08/20/sbom-component-types/</guid><description>&lt;p>CycloneDX and SPDX are two leading SBOM (Software Bill of Materials) standards, each with distinct strengths and support for various component types. CycloneDX is well-suited for modern, agile environments due to its broad support for containers, SaaS, and hardware-related components, making it ideal for organizations requiring a flexible, lightweight SBOM format. In contrast, SPDX excels in compliance-focused documentation, particularly for open-source software, offering extensive support for license information and provenance tracking. This makes SPDX the preferred choice in industries where legal and regulatory compliance is critical.&lt;/p>
&lt;h2 id="comparing-sbom-formats-focus-on-component-types-in-cyclonedx-vs-spdx">Comparing SBOM Formats: Focus on Component Types in CycloneDX vs. SPDX&lt;/h2>
&lt;p>When choosing between CycloneDX and SPDX for creating Software Bill of Materials (SBOMs), it&amp;rsquo;s essential to understand the different component types these standards support and how they align with various use cases. Both formats have their strengths, but their support for different component types varies, making them suitable for different environments and requirements. Let&amp;rsquo;s dive into the component types supported by each and what they are used for.&lt;/p>
&lt;h3 id="1-applications">1. &lt;strong>Applications&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>CycloneDX&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Component Type&lt;/strong>: Application&lt;/li>
&lt;li>&lt;strong>Usage&lt;/strong>: CycloneDX supports detailed SBOMs for entire applications, capturing all dependencies and modules involved. This is particularly useful for organizations needing a comprehensive view of their software products, including all embedded third-party software, to assess vulnerabilities and manage updates efficiently. CycloneDX&amp;rsquo;s flexibility makes it a preferred choice for agile environments where software components evolve rapidly.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>SPDX&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Component Type&lt;/strong>: Package&lt;/li>
&lt;li>&lt;strong>Usage&lt;/strong>: In SPDX, applications are typically represented as packages. SPDX excels in documenting the licensing and provenance of each component within the application, making it suitable for industries with strict compliance requirements, such as automotive or healthcare sectors. SPDX’s detailed package-level information helps ensure that all components meet the necessary legal and regulatory standards [1].&lt;/li>
&lt;/ul>
&lt;h3 id="2-libraries">2. &lt;strong>Libraries&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>CycloneDX&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Component Type&lt;/strong>: Library&lt;/li>
&lt;li>&lt;strong>Usage&lt;/strong>: CycloneDX supports library SBOMs with a focus on ease of integration and automation. It’s designed to help developers and security teams quickly identify vulnerable libraries and ensure that open-source components are up-to-date. The format is lightweight, making it easy to integrate into CI/CD pipelines for continuous monitoring.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>SPDX&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Component Type&lt;/strong>: Package, File, Snippet&lt;/li>
&lt;li>&lt;strong>Usage&lt;/strong>: SPDX offers more granularity with its support for packages, files, and snippets. This allows organizations to track and document every piece of a library, down to individual files and code snippets, along with their licensing information. This level of detail is particularly beneficial for managing open-source license compliance across large and complex codebases [2].&lt;/li>
&lt;/ul>
&lt;h3 id="3-containers">3. &lt;strong>Containers&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>CycloneDX&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Component Type&lt;/strong>: Container&lt;/li>
&lt;li>&lt;strong>Usage&lt;/strong>: CycloneDX is well-suited for container environments, providing detailed information about each layer within a container image. This includes everything from the base image to individual libraries and configurations used within the container. CycloneDX’s container SBOMs are valuable for DevOps teams looking to maintain consistency and security across development, testing, and production environments.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>SPDX&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Component Type&lt;/strong>: Package (representing containers)&lt;/li>
&lt;li>&lt;strong>Usage&lt;/strong>: While SPDX can document containers by treating them as packages, its primary strength lies in its detailed documentation of each component within the container. This includes extensive metadata on licensing and provenance, making SPDX useful in environments where understanding the legal and security implications of every component within a container is critical [3].&lt;/li>
&lt;/ul>
&lt;h3 id="4-operating-systems-and-devices">4. &lt;strong>Operating Systems and Devices&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>CycloneDX&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Component Type&lt;/strong>: Operating System, Device&lt;/li>
&lt;li>&lt;strong>Usage&lt;/strong>: CycloneDX extends beyond traditional software components to include operating systems and devices. This makes it ideal for scenarios where the interaction between software and hardware is a primary concern.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>SPDX&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Component Type&lt;/strong>: No direct equivalent&lt;/li>
&lt;li>&lt;strong>Usage&lt;/strong>: SPDX does not natively support the documentation of operating systems or devices. It is more focused on traditional software components like files, packages, and licenses [4].&lt;/li>
&lt;/ul>
&lt;h3 id="5-saas-and-services">5. &lt;strong>SaaS and Services&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>CycloneDX&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Component Type&lt;/strong>: Service&lt;/li>
&lt;li>&lt;strong>Usage&lt;/strong>: CycloneDX shines in environments that rely on cloud-native architectures, supporting the documentation of Software as a Service (SaaS) and other services. This includes external APIs, authentication mechanisms, and other service-related components.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>SPDX&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Component Type&lt;/strong>: No direct equivalent&lt;/li>
&lt;li>&lt;strong>Usage&lt;/strong>: SPDX does not natively support the documentation of SaaS or service components [5].&lt;/li>
&lt;/ul>
&lt;h2 id="references">References&lt;/h2>
&lt;ul>
&lt;li>[1] Sonatype. (n.d.). SPDX vs CycloneDX: Choosing the Right SBOM Format for Your Organization. Retrieved from &lt;a href="https://www.sonatype.com/blog/spdx-vs-cyclonedx/">https://www.sonatype.com/blog/spdx-vs-cyclonedx/&lt;/a>&lt;/li>
&lt;li>[2] Security Boulevard. (2020). CycloneDX vs SPDX: Which is Best for Your Use Case? Retrieved from &lt;a href="https://securityboulevard.com/2020/02/cyclonedx-vs-spdx-which-is-best-for-your-use-case/">https://securityboulevard.com/2020/02/cyclonedx-vs-spdx-which-is-best-for-your-use-case/&lt;/a>&lt;/li>
&lt;li>[3] Security Boulevard. (2020). Container Security with CycloneDX and SPDX. Retrieved from &lt;a href="https://securityboulevard.com/2020/03/container-security-with-cyclonedx-and-spdx/">https://securityboulevard.com/2020/03/container-security-with-cyclonedx-and-spdx/&lt;/a>&lt;/li>
&lt;li>[4] Sonatype. (n.d.). Operating System and Device Documentation with CycloneDX. Retrieved from &lt;a href="https://www.sonatype.com/blog/operating-system-and-device-documentation-with-cyclonedx/">https://www.sonatype.com/blog/operating-system-and-device-documentation-with-cyclonedx/&lt;/a>&lt;/li>
&lt;li>[5] Security Boulevard. (2020). SaaS and Service Documentation with CycloneDX. Retrieved from &lt;a href="https://securityboulevard.com/2020/04/saas-and-service-documentation-with-cyclonedx/">https://securityboulevard.com/2020/04/saas-and-service-documentation-with-cyclonedx/&lt;/a>&lt;/li>
&lt;/ul></description><category>education</category></item><item><title>Securing the Software Supply Chain with SLSA: What You Need to Know</title><link>https://sbomify.com/2024/08/17/what-is-slsa/</link><pubDate>Sat, 17 Aug 2024 00:00:00 +0000</pubDate><guid>https://sbomify.com/2024/08/17/what-is-slsa/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>In a world where software is integral to almost every aspect of life, securing the software supply chain is more critical than ever. The increasing complexity of software systems has given rise to sophisticated cyberattacks, particularly those targeting the software supply chain. To combat these threats, Google introduced &lt;strong>SLSA (Supply chain Levels for Software Artifacts)&lt;/strong>—a framework that provides a structured approach to safeguarding software development and ensuring that software artifacts are secure and tamper-free throughout their lifecycle. Pronounced &amp;ldquo;salsa,&amp;rdquo; SLSA is essential for defending against supply chain attacks, maintaining software integrity, providing transparency, encouraging best practices, and meeting compliance standards. Additionally, GitHub now supports artifact attestations, further enhancing the ability to establish and verify provenance within the SLSA framework.&lt;/p>
&lt;h2 id="what-is-slsa">What is SLSA?&lt;/h2>
&lt;p>SLSA, which stands for Supply chain Levels for Software Artifacts, is a security framework designed to protect the integrity of software artifacts from the earliest stages of development through to deployment. Introduced by Google, SLSA offers a standardized approach to securing the software supply chain, addressing vulnerabilities that could otherwise be exploited by cybercriminals.&lt;/p>
&lt;p>The framework is structured into four levels, each corresponding to a progressively higher degree of security maturity:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>SLSA Level 1: Basic Build Integrity&lt;/strong>
At this foundational level, organizations implement basic security practices, such as using version control systems (VCS) and documenting their build processes. This establishes a baseline for more advanced security measures.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>SLSA Level 2: Higher Build Integrity&lt;/strong>
Building on Level 1, this stage introduces stronger controls like using a dedicated build service to prevent unauthorized changes. The goal is to enhance the integrity of the software as it progresses through the development pipeline.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>SLSA Level 3: Provenance&lt;/strong>
Provenance is a key feature at this level, offering traceability and transparency regarding the origin of software artifacts. This level ensures that organizations can verify the entire history of their software, including who built it and how it was built. GitHub, one of the most widely used platforms for software development, now supports artifact attestations, enabling developers to create and verify attestations for software artifacts built using GitHub Actions. This capability allows organizations to seamlessly integrate provenance tracking into their development workflows, aligning with SLSA Level 3 requirements.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>SLSA Level 4: Hermetic Builds and Two-Person Review&lt;/strong>
The highest level of SLSA emphasizes maximum security with hermetic builds—completely isolated build environments—and a mandatory two-person review process. These practices help detect any issues before software deployment, ensuring the highest level of security.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="why-slsa-matters">Why SLSA Matters&lt;/h2>
&lt;p>The importance of SLSA in today’s digital landscape cannot be overstated. As cyber threats continue to evolve, securing the software supply chain has become essential to preventing widespread damage and maintaining trust in digital systems. Here’s why SLSA is crucial:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Defending Against Supply Chain Attacks&lt;/strong>
Supply chain attacks are a growing concern, with attackers targeting the software development process to introduce malicious code. SLSA helps organizations defend against these threats by implementing robust security measures at every stage of software development.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Ensuring Software Integrity and Trust&lt;/strong>
SLSA ensures that software remains untampered throughout its lifecycle, which is critical for maintaining trust, especially in industries where security is paramount, such as healthcare, finance, and government.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Providing Transparency with Provenance&lt;/strong>
The concept of provenance, introduced at SLSA Level 3, offers a clear record of the software’s origin and development history. With GitHub&amp;rsquo;s support for artifact attestations, organizations can now generate and verify these attestations directly within their development workflows, ensuring that the software’s authenticity and history are transparent and verifiable.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Encouraging Adoption of Best Practices&lt;/strong>
By following the SLSA framework, organizations naturally adopt industry best practices for software security. This strengthens their own systems and contributes to the overall security of the software ecosystem.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Achieving Compliance and Regulatory Standards&lt;/strong>
With cybersecurity regulations becoming more stringent, adhering to SLSA can help organizations meet compliance requirements, avoiding legal consequences and demonstrating a commitment to security that can serve as a competitive advantage.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>By adopting SLSA and leveraging tools like GitHub&amp;rsquo;s artifact attestations, organizations can protect their software from threats, ensure its integrity, and contribute to a safer digital environment for all.&lt;/p></description><category>education</category></item><item><title>Understanding in-toto: Securing the Software Supply Chain</title><link>https://sbomify.com/2024/08/14/what-is-in-toto/</link><pubDate>Wed, 14 Aug 2024 00:00:00 +0000</pubDate><guid>https://sbomify.com/2024/08/14/what-is-in-toto/</guid><description>&lt;p>In today&amp;rsquo;s software landscape, securing the software supply chain is more crucial than ever. With increasing concerns about vulnerabilities and supply chain attacks, developers and organizations are looking for robust solutions to ensure the integrity of their software from development to deployment. One such solution is &lt;strong>&lt;a href="https://github.com/in-toto/in-toto">in-toto&lt;/a>&lt;/strong>. In this post, we&amp;rsquo;ll explore what in-toto is, how it works, and why it might be the key to securing your software supply chain.&lt;/p>
&lt;h3 id="what-is-in-toto">What is in-toto?&lt;/h3>
&lt;p>In-toto is an open-source framework designed to secure the entire software supply chain. It provides a way to ensure that all steps in the software development and deployment process are executed as intended, without tampering or unintended changes. The name &amp;ldquo;in-toto&amp;rdquo; is derived from the Latin phrase &amp;ldquo;in toto,&amp;rdquo; meaning &amp;ldquo;in total&amp;rdquo; or &amp;ldquo;completely,&amp;rdquo; which reflects the framework&amp;rsquo;s comprehensive approach to security.&lt;/p>
&lt;p>The in-toto framework was originally developed by researchers at New York University as part of the Supply Chain Integrity, Transparency, and Trust (SCITT) project. It is now maintained as an open-source project and has been adopted by various organizations to enhance the security of their development pipelines.&lt;/p>
&lt;h3 id="how-does-in-toto-work">How Does in-toto Work?&lt;/h3>
&lt;p>In-toto operates by establishing a chain of trust throughout the entire software supply chain. It does this through a series of steps:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Defining a Layout&lt;/strong>: The first step in using in-toto is to define a &amp;ldquo;layout,&amp;rdquo; which is essentially a blueprint of the software supply chain. The layout specifies the steps involved in the development process, the expected materials and products of each step, and the parties responsible for executing those steps.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Creating and Signing Link Metadata&lt;/strong>: As each step in the layout is executed, in-toto generates &amp;ldquo;link metadata,&amp;rdquo; which records the details of the step, including the command run, the materials used (such as source code), and the products generated (such as binaries). This metadata is then signed by the entity responsible for the step, creating a cryptographic proof of its execution.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Verifying the Supply Chain&lt;/strong>: Once all steps are completed, in-toto verifies the entire supply chain by checking that each step was executed according to the layout and that the link metadata is valid. This ensures that no unauthorized changes were made during the process.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Reproducibility and Transparency&lt;/strong>: In-toto emphasizes transparency by making all the metadata and verification processes open and auditable. This allows for third-party verification and ensures that the integrity of the software can be independently verified.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="why-is-in-toto-important">Why is in-toto Important?&lt;/h3>
&lt;p>In-toto addresses several key challenges in securing the software supply chain:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Preventing Supply Chain Attacks&lt;/strong>: By providing end-to-end verification of the software supply chain, in-toto helps prevent attacks where malicious actors might attempt to inject vulnerabilities during the development process.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Ensuring Compliance&lt;/strong>: For organizations that need to comply with regulatory requirements or internal security policies, in-toto provides a clear and auditable trail of the software&amp;rsquo;s development history.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Building Trust&lt;/strong>: In-toto&amp;rsquo;s transparent and verifiable process builds trust among developers, users, and stakeholders, ensuring that the software they rely on has not been tampered with.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="real-world-use-cases">Real-World Use Cases&lt;/h3>
&lt;p>In-toto has been adopted by several organizations and integrated into popular tools and frameworks:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>The Open Source Security Foundation (OpenSSF)&lt;/strong>: In-toto is part of the OpenSSF&amp;rsquo;s efforts to secure open-source software, providing a framework to protect against supply chain attacks in critical open-source projects.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Tern&lt;/strong>: Tern, a tool for container image inspection, uses in-toto to track and verify the steps involved in building a container image, ensuring its integrity.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Datadog&lt;/strong>: Datadog, a cloud monitoring platform, has integrated in-toto into its CI/CD pipeline to secure the delivery of its software updates.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="getting-started-with-in-toto">Getting Started with in-toto&lt;/h3>
&lt;p>To start using in-toto, you can visit the &lt;a href="https://github.com/in-toto/in-toto">in-toto GitHub repository&lt;/a> for detailed documentation and examples. The repository provides guides on how to define layouts, generate link metadata, and verify the software supply chain.&lt;/p>
&lt;p>In-toto is implemented in Python, and you can install it via pip:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install in-toto
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>From there, you can start defining your software supply chain&amp;rsquo;s layout and securing your development pipeline.&lt;/p>
&lt;h3 id="wrapping-up">Wrapping up&lt;/h3>
&lt;p>In-toto offers a powerful and flexible framework for securing the software supply chain, addressing the growing concerns of supply chain attacks and software integrity. By incorporating in-toto into your development processes, you can ensure that your software is built and delivered exactly as intended, without any unauthorized changes. As supply chain security becomes increasingly important, tools like in-toto are invaluable in safeguarding the integrity of your software.&lt;/p>
&lt;p>Stay secure, and happy coding!&lt;/p></description><category>education</category></item><item><title>Understanding Sigstore: Securing the Software Supply Chain</title><link>https://sbomify.com/2024/08/12/what-is-sigstore/</link><pubDate>Mon, 12 Aug 2024 00:00:00 +0000</pubDate><guid>https://sbomify.com/2024/08/12/what-is-sigstore/</guid><description>&lt;p>&lt;strong>Summary&lt;/strong>: In an era where software supply chain attacks are becoming more common and sophisticated, &lt;a href="https://www.sigstore.dev/">Sigstore&lt;/a> represents a critical advancement in securing software development practices. By lowering the barriers to cryptographic signing and increasing the transparency of the signing process, Sigstore helps ensure that the software we all rely on is both secure and trustworthy. Whether you&amp;rsquo;re a developer, a security professional, or a software user, the adoption of Sigstore has the potential to significantly enhance the integrity of the software ecosystem.&lt;/p>
&lt;h2 id="what-is-sigstore">What is Sigstore?&lt;/h2>
&lt;p>Sigstore is an open-source project that provides a set of tools and services for developers to cryptographically sign, verify, and protect their software artifacts. This includes container images, binaries, and source code, among other elements. The primary goal of Sigstore is to make signing software artifacts as easy and widely adopted as possible, thereby increasing the overall trust in the software supply chain.&lt;/p>
&lt;p>Sigstore was born out of a collaboration between Google, Red Hat, Purdue University, and other key contributors in the open-source community. The project has quickly gained momentum due to its focus on addressing critical security concerns in modern software development practices.&lt;/p>
&lt;h2 id="why-sigstore-matters">Why Sigstore Matters&lt;/h2>
&lt;p>The integrity of software artifacts is essential to prevent malicious code from infiltrating production systems. Traditionally, ensuring this integrity has involved complex processes of generating, managing, and distributing cryptographic keys for signing software. These processes, while effective, are often cumbersome, leading to low adoption rates and a general lack of cryptographic signing in many projects.&lt;/p>
&lt;p>Sigstore simplifies this process by providing a transparent, community-driven solution that reduces the barriers to entry for signing software artifacts. This democratization of signing practices helps ensure that more software components are cryptographically verified, making it harder for attackers to introduce malicious code into the software supply chain.&lt;/p>
&lt;h2 id="key-components-of-sigstore">Key Components of Sigstore&lt;/h2>
&lt;p>Sigstore is comprised of several key components that work together to provide a secure and user-friendly signing experience:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Cosign&lt;/strong>: A command-line tool that enables developers to sign, verify, and store signatures for container images and other artifacts. Cosign leverages existing cloud-native technologies and integrates seamlessly with popular CI/CD pipelines, making it easy to incorporate signing into existing workflows.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Rekor&lt;/strong>: A transparency log service that records all signature and metadata information in a tamper-evident manner. Rekor acts as a public ledger, allowing anyone to verify the integrity of an artifact and its associated signature. This transparency log is critical for ensuring that signed artifacts cannot be altered without detection.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Fulcio&lt;/strong>: A certificate authority (CA) that issues short-lived certificates based on OpenID Connect (OIDC) identities. Fulcio enables developers to obtain cryptographic certificates without the need for complex key management, streamlining the process of signing artifacts.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Gitsign&lt;/strong>: A tool for signing Git commits and tags using Sigstore&amp;rsquo;s infrastructure. Gitsign ensures that code changes can be traced back to their source, providing an additional layer of security for version control systems.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="how-sigstore-works">How Sigstore Works&lt;/h2>
&lt;p>Sigstore&amp;rsquo;s architecture is designed to be both secure and easy to use. When a developer signs an artifact using Cosign, the following steps typically occur:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Obtain a Certificate&lt;/strong>: The developer uses Fulcio to obtain a short-lived certificate, which is tied to their OIDC identity (such as a GitHub or Google account). This certificate is used to sign the artifact.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Sign the Artifact&lt;/strong>: The developer uses Cosign to create a signature for the artifact. This signature, along with the certificate, is then uploaded to Rekor&amp;rsquo;s transparency log.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Store and Verify&lt;/strong>: The signed artifact, along with its signature and certificate, can be stored in a registry. Anyone can later verify the artifact by checking the signature against the information in Rekor&amp;rsquo;s transparency log.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>This process ensures that the integrity and origin of the software artifact can be independently verified by anyone, making it much harder for malicious actors to compromise the software supply chain.&lt;/p>
&lt;h2 id="the-benefits-of-sigstore">The Benefits of Sigstore&lt;/h2>
&lt;p>Sigstore offers several significant benefits to the software development community:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Enhanced Security&lt;/strong>: By making cryptographic signing accessible and easy to use, Sigstore helps protect against supply chain attacks and other security threats.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Transparency&lt;/strong>: The use of a public transparency log ensures that all signed artifacts are publicly auditable, increasing trust in the software supply chain.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Ease of Use&lt;/strong>: Sigstore&amp;rsquo;s integration with existing tools and workflows means that developers can adopt secure signing practices without significant changes to their processes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Community-Driven&lt;/strong>: As an open-source project, Sigstore benefits from the contributions and oversight of a broad community, ensuring that it remains responsive to the needs of developers and organizations.&lt;/p>
&lt;/li>
&lt;/ul></description><category>education</category></item><item><title>Understanding Lock File Drift: A Hidden Risk in Dependency Management</title><link>https://sbomify.com/2024/07/31/what-is-lock-file-drift/</link><pubDate>Wed, 31 Jul 2024 09:00:35 +0200</pubDate><guid>https://sbomify.com/2024/07/31/what-is-lock-file-drift/</guid><description>&lt;p>In the world of software development, managing dependencies is crucial for ensuring the stability and security of applications. One often overlooked aspect of this process is the phenomenon known as &amp;ldquo;lock file drift,&amp;rdquo; where the dependency lock file is out of sync with the primary dependency file. This misalignment can lead to inconsistent builds, security vulnerabilities, and compatibility issues, ultimately compromising the integrity and functionality of a project. By understanding the causes of lock file drift and implementing best practices to detect and prevent it, development teams can maintain consistent, secure, and reliable builds.&lt;/p>
&lt;h2 id="what-is-a-lock-file">What is a Lock File?&lt;/h2>
&lt;p>Before diving into lock file drift, it&amp;rsquo;s essential to understand the purpose of lock files. In most modern package managers, a lock file (such as &lt;code>package-lock.json&lt;/code> for npm or &lt;code>Pipfile.lock&lt;/code> for Pipenv) records the exact versions of dependencies installed in a project. This ensures that all environments (development, staging, production) use the same dependency versions, leading to consistent and reproducible builds.&lt;/p>
&lt;h2 id="the-emergence-of-lock-file-drift">The Emergence of Lock File Drift&lt;/h2>
&lt;p>Lock file drift occurs when the lock file becomes unsynchronized with the primary dependency file (&lt;code>package.json&lt;/code>, &lt;code>Pipfile&lt;/code>, &lt;code>requirements.txt&lt;/code> etc.). This misalignment can happen due to several reasons:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Manual Editing:&lt;/strong> Developers manually update the primary dependency file without running the package manager to regenerate the lock file.&lt;/li>
&lt;li>&lt;strong>Merge Conflicts:&lt;/strong> In a collaborative environment, different branches might modify dependencies, leading to conflicts that are not correctly resolved in both files.&lt;/li>
&lt;li>&lt;strong>Automated Tools:&lt;/strong> Continuous integration (CI) tools or scripts might update dependencies but fail to refresh the lock file accordingly.&lt;/li>
&lt;/ol>
&lt;h2 id="consequences-of-lock-file-drift">Consequences of Lock File Drift&lt;/h2>
&lt;p>Lock file drift can introduce significant risks and challenges to a project:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Inconsistent Builds:&lt;/strong> When the lock file and the primary dependency file are out of sync, different environments might install varying versions of dependencies, leading to inconsistencies. This makes debugging difficult and can result in unexpected behavior in production.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Security Vulnerabilities:&lt;/strong> Lock file drift can prevent critical security updates from being applied. If the primary dependency file specifies a newer, secure version of a package but the lock file remains outdated, the application could be exposed to known vulnerabilities.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Compatibility Issues:&lt;/strong> Dependencies often rely on specific versions of other packages. A drifted lock file might cause version mismatches, leading to compatibility issues and potential runtime errors.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="detecting-and-preventing-lock-file-drift">Detecting and Preventing Lock File Drift&lt;/h2>
&lt;p>To mitigate the risks associated with lock file drift, teams can adopt several best practices:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Regular Audits:&lt;/strong> Periodically check that the lock file is in sync with the primary dependency file. Tools like &lt;code>npm audit&lt;/code> or &lt;code>pipenv check&lt;/code> can help identify discrepancies and vulnerabilities.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Automated CI Checks:&lt;/strong> Integrate checks into your CI pipeline to ensure the lock file is updated whenever the primary dependency file changes. This can be achieved by running commands like &lt;code>npm install&lt;/code> or &lt;code>pipenv install&lt;/code> during the CI process.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Consistent Workflow:&lt;/strong> Encourage developers to follow a consistent workflow where changes to dependencies are always followed by regenerating the lock file. This can be enforced through pre-commit hooks or other automated scripts.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Education and Awareness:&lt;/strong> Educate your development team about the importance of&lt;/p>
&lt;/li>
&lt;/ol></description><category>education</category></item><item><title>How to Generate SBOMs for Python Packages with `pipdeptree` and `cyclonedx-py`</title><link>https://sbomify.com/2024/07/30/generate-sboms-for-python-packages-with-pipdeptree-and-cyclonedx-py/</link><pubDate>Tue, 30 Jul 2024 09:00:35 +0200</pubDate><guid>https://sbomify.com/2024/07/30/generate-sboms-for-python-packages-with-pipdeptree-and-cyclonedx-py/</guid><description>&lt;p>Software Bill of Materials (SBOMs) are essential for ensuring transparency and security in software supply chains. This guide will show you how to use &lt;code>pipdeptree&lt;/code> and &lt;code>cyclonedx-py&lt;/code> to generate SBOMs for Python projects, including all transient dependencies. We&amp;rsquo;ll also reference a comprehensive guide on generating SBOMs for Python packages using Docker and Django CMS.&lt;/p>
&lt;h2 id="why-sboms-matter">Why SBOMs Matter&lt;/h2>
&lt;p>SBOMs provide a detailed inventory of all components in a software project, helping with:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Security&lt;/strong>: Identifying and fixing vulnerabilities.&lt;/li>
&lt;li>&lt;strong>Compliance&lt;/strong>: Meeting legal and regulatory standards.&lt;/li>
&lt;li>&lt;strong>Maintenance&lt;/strong>: Ensuring software stability.&lt;/li>
&lt;/ul>
&lt;p>See our article &lt;a href="https://sbomify.com/what-is-sbom/">What is an SBOM&lt;/a> for more details.&lt;/p>
&lt;h2 id="step-by-step-guide-to-generating-sboms">Step-by-Step Guide to Generating SBOMs&lt;/h2>
&lt;h3 id="using-pipdeptree-for-dependency-analysis">Using &lt;code>pipdeptree&lt;/code> for Dependency Analysis&lt;/h3>
&lt;p>&lt;code>pipdeptree&lt;/code> visualizes the dependency tree of installed Python packages, making it ideal for SBOM generation.&lt;/p>
&lt;h4 id="installation">Installation&lt;/h4>
&lt;p>Install &lt;code>pipdeptree&lt;/code> with pip:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install pipdeptree
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="generate-the-dependency-tree">Generate the Dependency Tree&lt;/h4>
&lt;p>Run this command to see the dependency tree and save it to a &lt;code>requirements.txt&lt;/code> file:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pipdeptree --freeze &amp;gt; requirements.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This output includes all installed packages and their dependencies, providing the necessary data for a comprehensive SBOM.&lt;/p>
&lt;h3 id="exploding-the-sbom">Exploding the SBOM&lt;/h3>
&lt;p>To fully capture all dependencies, including transient ones, it&amp;rsquo;s essential to &amp;ldquo;explode&amp;rdquo; the SBOM. &lt;code>pipdeptree&lt;/code> does this effectively by mapping out the entire dependency tree.&lt;/p>
&lt;h3 id="converting-pipdeptree-output-to-cyclonedx-format">Converting &lt;code>pipdeptree&lt;/code> Output to CycloneDX Format&lt;/h3>
&lt;p>Once you have the dependency tree from &lt;code>pipdeptree&lt;/code>, you can convert it to a CycloneDX SBOM using the CycloneDX-Python tool.&lt;/p>
&lt;h4 id="installation-1">Installation&lt;/h4>
&lt;p>Install CycloneDX-Python with pip:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install cyclonedx-bom
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="conversion-process">Conversion Process&lt;/h4>
&lt;p>First, generate the dependency tree and save it to a file using the previous &lt;code>pipdeptree&lt;/code> command. Then, convert this &lt;code>requirements.txt&lt;/code> file to a CycloneDX SBOM:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cyclonedx-py &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --requirements requirements.txt &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --output sbom.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This process ensures all dependencies, including transient ones, are captured in the SBOM.&lt;/p>
&lt;h3 id="best-practices-for-managing-dependencies">Best Practices for Managing Dependencies&lt;/h3>
&lt;p>Pinning all dependencies, ideally with hashes, enhances security and compliance, aligning with standards like the OpenSSF Scorecards.&lt;/p>
&lt;h4 id="pinning-dependencies-with-hashes">Pinning Dependencies with Hashes&lt;/h4>
&lt;p>Specify versions and hashes in your &lt;code>requirements.txt&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>package==version --hash=sha256:hash
&lt;/code>&lt;/pre>&lt;p>This ensures you&amp;rsquo;re using verified dependency versions, reducing the risk of vulnerabilities.&lt;/p>
&lt;h3 id="wrapping-up">Wrapping up&lt;/h3>
&lt;p>For a thorough walkthrough on generating SBOMs, check out our &lt;a href="https://sbomify.com/2024/05/27/comprehensive-guide-to-generating-and-understanding-sboms-with-docker-and-django-cms/">comprehensive guide&lt;/a>. This resource covers generating SBOMs using Docker and Django CMS, with applicable insights for any Python project.&lt;/p>
&lt;p>Generating SBOMs for Python packages, including all dependencies, is vital for security and compliance. Tools like &lt;code>pipdeptree&lt;/code> and CycloneDX-Python make this process straightforward. By following best practices such as pinning dependencies with hashes, you can further secure your project.&lt;/p></description><category>guide</category></item></channel></rss>